
<!doctype html>














<html class="theme-next muse use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/assets/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/assets/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/assets/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="algorithm,approximation," />





  <link rel="alternate" href="/atom.xml" title="REAL" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/assets/favicon.ico?v=5.1.1" />
















<meta name="description" content="Survivable network design is a problem that designing a network that can survive from disconnecting some edges.">
<meta name="keywords" content="algorithm, approximation">
<meta property="og:type" content="article">
<meta property="og:title" content="Approximation algorithm(9) - survivable network design">
<meta property="og:url" content="https://programelot.github.io/2021/04/17/Approximation-algorithm(9)/">
<meta property="og:site_name" content="REAL">
<meta property="og:description" content="Survivable network design is a problem that designing a network that can survive from disconnecting some edges.">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Approximation algorithm(9) - survivable network design">
<meta name="twitter:description" content="Survivable network design is a problem that designing a network that can survive from disconnecting some edges.">


<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://programelot.github.io/"/>





  <title>Approximation algorithm(9) - survivable network design | REAL</title>
  
















</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> <div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">REAL</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            About
          </a>
        </li>
      
        
        
        
        <li class="menu-item menu-item-project">
          <a href="/projects/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Project
          </a>
        </li>
      
        
        
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            Search
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="Searching..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



<script>
    var pageId = extractId('/2021/04/17/Approximation-algorithm(9)/');
    var visited = parseInt(localStorage[pageId] || 0);

    function extractId(raw_page_url){
        return raw_page_url.replace(/[^A-Za-z0-9]/g, '').substring(0,64);
    };

    function num_dot_add(input){
        input = input.toString();
        output = '';
        for(let s = 0; s < input.length; ++s){
            if(s != input.length && s % 3 == 0 && s != 0)
                output = ',' + output;
                output = input[input.length - 1 - s] + output;
        }
        return output
    }

    function setVisitorCount(){
        var xhr = new XMLHttpRequest();
        if(visited == 0){
            xhr.open("GET", `https://api.countapi.xyz/hit/programelot.github.io/` + pageId);
            localStorage[pageId] = 1;
        }
        else{
            xhr.open("GET", `https://api.countapi.xyz/get/programelot.github.io/` + pageId);
        }
        xhr.responseType = "json";
        xhr.onload = function() {
            document.getElementsByClassName('visitors-count')[0].innerText = num_dot_add(this.response.value);
        }
        xhr.send();
    }
    setVisitorCount();
</script>


 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

<div id="posts" class="posts-expand">
  
  

  

  
  
  

  <article class="post post-type- " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://programelot.github.io/2021/04/17/Approximation-algorithm(9)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Programelot">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="assets/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="REAL">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
          
          
            Approximation algorithm(9) - survivable network design
          
        </h1>
        


        <div class="post-meta">
          
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-04-17T00:00:00+09:00">
                00-17-2021
              </time>
            

            

            
          </span>
          

          

          
            
          

          
          
            
             <span id="/2021/04/17/Approximation-algorithm(9)/" class="visitors" data-flag-title="Approximation algorithm(9) - survivable network design">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">Visitors </span>
               
                 <span class="visitors-count"></span>
             </span>
             
          
          

          
          

          

          

          
            
                <div class="post-description">
                    
                </div>
            
          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
  
  












  <p>Survivable network design is a problem that designing a network that can survive from disconnecting some edges.</p>

<p>Let’s assume that there is a given undirected graph $G = (V,E)$ with costs $c_e \ge 0$ $\forall e \in E$.
Now, let’s define connectivity requirments $r_{ij} \in \mathbb{Z}^{+} \cup \{0\}$ for all pairs of vertices $i,j \in V$, where $i \neq j$.
Then problem is a find a minimum cost set of edges $F \subset E$ such that $G’ = (V,F)$ has $r_{ij}$ edge distinct paths to connecting $i$ and $j$.</p>

<p>Now, we can make a integer programming over this and it is like follow.
“Minimize $\sum\limits_{e \in E} c_e x_e$ such that $\sum\limits_{e \in \delta(S)} x_e \ge \max\limits_{i \in S, j \not\in S} r_{ij}$ $\forall S \subset V$, $x_e \in \{0,1\}$” which $\delta(S)$ denotes the set of edges between $S$ and $V - S$.
Notice that if there is $r_{ij}$ edge distinct paths, we can make a flow of value $r_{ij}$ between $i$ and $j$.
Then, there should be a mincut that corresponding to that flow from the network flow theory.
As a result, constraint above should be fulfilled.
It’s the same in the opposite direction.
If we have a such min-cut then we have such flow either.</p>

<p>Now, we can do a linear programming relaxation like we did in the set cover.
“Minimize $\sum\limits_{e \in E} c_e x_e$ such that $\sum\limits_{e \in \delta(S)} x_e \ge \max\limits_{i \in S, j \not\in S} r_{ij}$ $\forall S \subset V$, $0 \le x_e \le 1$”.
We can solve this LP in polynomial time with ellipsoid method.
We can construct a seperation orcale like follow.</p>
<ol>
  <li>Make a graph that consists of $G = (V,E)$ and set capacity of $E$ as $x_e$.</li>
  <li>Solve the network flow problem between all pair $i$ and $j$ such that $i \neq j$ and $i,j \in V$.</li>
  <li>If there is a flow such that the value of flow $f_{ij}$ is less than $r_{ij}$ then it’s an infeasible solution otherwise it is feasible.</li>
</ol>

<p>Now, let’s define $f(S) = \max\limits_{i \in S, j \not\in S} r_{ij}$.
Then problem will be shifted to “Minimize $\sum\limits_{e \in E} c_e x_e$ such that $\sum\limits_{e \in \delta(S)} x_e \ge f(S)$ $\forall S \subset V$, $0 \le x_e \le 1$”.</p>

<p>If we make $f(S)$ as so then $f(S)$ is so-called weakly supermodular.
To be a weakly supermodular, there are some requirements.</p>
<ol>
  <li>$f(\emptyset) = f(U) = 0$ for ground set $U$.</li>
  <li>one of $f(A) + f(B)$ $\le$ $f(A \cap B) + f(A \cup B)$ or $f(A) + f(B)$ $\le$ $f(A - B) + f(B - A)$ should be true.</li>
</ol>

<p>Proof is like follow.
First, it is trivial that $f(\emptyset) = f(V) = 0$ because there is no such an edge between $V$ and $\emptyset$.
Before we prove the second requirments, $f(A) = f(V - A)$ is trivial either.
Also, we have $max(f(A), f(B)) \ge f(A \cup B)$.
Because if we think about $i \in A \cup B, j \not\in A \cup B$ then it should be one of “$i \in A, j \not\in A$ or $i \in B, j \not\in B$”.</p>

<p>Now, we can make 4 property of $f$ from the fact above.</p>

<ol>
  <li>$f(A)$ $\le$ $\max(f(A - B), f(A \cap B))$</li>
  <li>$f(A)$ $=$ $f(V - A)$ $\le$ $\max(f(B - A),$ $f(V - (A \cup B)))$ $=$ $\max(f(B - A),$ $f(A \cup B))$</li>
  <li>$f(B)$ $\le$ $\max(f(B - A), f(A \cap B))$</li>
  <li>$f(B)$ $=$ $f(V - B)$ $\le$ $\max(f(A - B),$ $f(V - (A \cup B)))$ $=$ $\max(f(A - B),$ $f(A \cup B))$</li>
</ol>

<p>Notice that $(A - B)$ $\cup$ $(A \cap B)$ $=$ $A$, $(V - (A \cup B))$ $\cup$ $(B - A)$ $=$ $V$ $-$ $A$, 
$(B - A)$ $\cup$ $(A \cap B)$ $=$ $B$ and $(V- (A \cup B))$ $\cup$ $(A - B)$ $=$ $V$ $-$ $B$.</p>

<p>This implies 4 inequalities.</p>

<ol>
  <li>$f(A) + f(B)$ $\le$ $\max(f(A - B), f(A \cap B))$ $+$ $\max(f(B - A), f(A \cap B))$</li>
  <li>$f(A) + f(B)$ $\le$ $\max(f(A - B), f(A \cap B))$ $+$ $\max(f(A - B), f(A \cup B))$</li>
  <li>$f(A) + f(B)$ $\le$ $\max(f(B - A), f(A \cup B))$ $+$ $\max(f(B - A), f(A \cap B))$</li>
  <li>$f(A) + f(B)$ $\le$ $\max(f(B - A), f(A \cup B))$ $+$ $\max(f(A - B), f(A \cup B))$</li>
</ol>

<p>Then, we can make possible inequality for weakly supermodular in any case.</p>
<ol>
  <li>$f(A) + f(B)$ $\le$ $\max(f(A - B), f(A \cap B))$ $+$ $\max(f(B - A), f(A \cap B))$ $=$ $f(A - B)$ $+$ $f(B - A)$ if $f(A - B), f(B - A)$ $\ge$ $f(A \cap B)$</li>
  <li>$f(A) + f(B)$ $\le$ $\max(f(A - B), f(A \cap B))$ $+$ $\max(f(A - B), f(A \cup B))$ $=$ $f(A \cap B)$ $+$ $f(A \cup B)$ if $f(A \cap B), f(A \cup B)$ $\ge$ $f(A - B)$</li>
  <li>$f(A) + f(B)$ $\le$ $\max(f(B - A), f(A \cup B))$ $+$ $\max(f(B - A), f(A \cap B))$ $=$ $f(A \cap B)$ $+$ $f(A \cup B)$ if $f(A \cap B), f(A \cup B)$ $\ge$ $f(B - A)$</li>
  <li>$f(A) + f(B)$ $\le$ $\max(f(B - A), f(A \cup B))$ $+$ $\max(f(A - B), f(A \cup B))$ $=$ $f(A - B)$ $+$ $f(B - A)$ if $f(A - B), f(B - A)$ $\ge$ $f(A \cup B)$</li>
</ol>

<p>Notice that if all requirements is false then all following should be true.</p>

<ol>
  <li>$\min(f(A - B), f(B - A))$ $&lt;$ $f(A \cap B)$</li>
  <li>$\min(f(A \cap B), f(A \cup B))$ $&lt;$ $f(A - B)$</li>
  <li>$\min(f(A \cap B), f(A \cup B))$ $&lt;$ $f(B - A)$</li>
  <li>$\min(f(A - B), f(B - A))$ $&lt;$ $f(A \cup B)$</li>
</ol>

<p>Then, it is a contraction because of following reasoning.</p>

<p>$\min(f(A - B), f(B - A))$ $&lt;$ $\min(f(A \cap B), f(A \cup B))$ from 1, 4<br />
$\min(f(A \cap B), f(A \cup B))$ $&lt;$ $\min(f(A - B), f(B - A))$ from 2, 3<br />
$\min(f(A \cap B), f(A \cup B))$ $&lt;$ $\min(f(A - B), f(B - A))$ $&lt;$ $\min(f(A \cap B), f(A \cup B))$ from above two.<br />
As a result, $\min(f(A \cap B), f(A \cup B))$ $&lt;$ $\min(f(A \cap B), f(A \cup B))$ and it can’t be true.
Therefore, $f$ is a weakly supermodular.</p>

<p>Now, there is a nice property of a weakly supermodular $f$.
There exists an edge $e \in E$ such that $x_e \ge \frac{1}{2}$ if we solve linear problem “Minimize $\sum\limits_{e \in E} c_e x_e$ such that $\sum\limits_{e \in \delta(S)} x_e \ge f(S)$ $\forall S \subset V$, $0 \le x_e \le 1$” for any weakly supermodular $f$.
Proof will be followed at the end of the post.</p>

<p>From the fact above, we can construct an algorithm.</p>

<div class="algTab">
    $F \leftarrow \emptyset$<br />
    $i \leftarrow 1$<br />
    $\operatorname{while}$ $F$ is not a feasible solution $\textbf{do}$<div class="algTab">
        Solve "Minimize $\sum\limits_{e \in E - F} c_e x_e$ such that $\sum\limits_{e \in \delta(S), e \in E - F} x_e \ge f_i(S) = f(S) - |\delta(S) \cap F|$ $\forall S \subset V$, $0 \le x_e \le 1$"<br />
        $F_i \leftarrow \{ e \in E - F \vert x_e \ge \frac{1}{2} \}$<br />
        $F \leftarrow F \cup F_i$<br />
        $i \leftarrow i + 1$
    </div>
    $\textbf{return} \text{ } F$
</div>

<p>Notice that it is so-called $\operatorname{iterative rounding}$ because it uses LP-relxation to extend solution and iterates it many times.</p>

<p>If the algorithm above terminates, solution should be feasible.
Now, we will show that solution will be in $2\operatorname{OPT}$ and it terminates.</p>

<p>First of all, we will show “If we define $z(e) \ge 0$ for all $e \in E$ and define $z(E) = \sum\limits_{e \in E}z(e)$ then 
$z(\delta(A)) + z(\delta(B))$ $\ge$ $z(\delta(A \cup B)) + z(\delta(A \cap B))$ and $z(\delta(A)) + z(\delta(B))$ $\ge$ $z(\delta(A - B)) + z(\delta(B - A))$ for any $A, B \subset V$”.</p>

<p>Proof is like follow.
If you think about the category of edges in $\delta(A)$, it will be one of follows.</p>
<ol>
  <li>$i \in A - B$, $j \in V - (A \cup B)$</li>
  <li>$i \in A \cap B$, $j \in V - (A \cup B)$</li>
  <li>$i \in A - B$, $j \in B - A$</li>
  <li>$i \in A \cap B$, $j \in B - A$</li>
</ol>

<p>It’s the same for the B either.
Therefore, $z(\delta(A)) + z(\delta(B))$ will be sum of $z(e)$ in following 8 categories.</p>
<ol>
  <li>$i \in A - B$, $j \in V - (A \cup B)$</li>
  <li>$i \in A \cap B$, $j \in V - (A \cup B)$</li>
  <li>$i \in A - B$, $j \in B - A$</li>
  <li>$i \in A \cap B$, $j \in B - A$</li>
  <li>$i \in B - A$, $j \in V - (A \cup B)$</li>
  <li>$i \in A \cap B$, $j \in V - (A \cup B)$</li>
  <li>$i \in B - A$, $j \in A - B$</li>
  <li>$i \in A \cap B$, $j \in A - B$</li>
</ol>

<p>If you think about the category of edges in $\delta(A \cup B)$, it will be one of follows.</p>
<ol>
  <li>$i \in A - B$, $j \in V - (A \cup B)$</li>
  <li>$i \in A \cap B$, $j \in V - (A \cup B)$</li>
  <li>$i \in B - A$, $j \in V - (A \cup B)$</li>
</ol>

<p>If you think about the category of edges in $\delta(A \cap B)$, it will be one of follows.</p>
<ol>
  <li>$i \in A \cap B$, $j \in V - (A \cup B)$</li>
  <li>$i \in A \cap B$, $j \in B - A$</li>
  <li>$i \in A \cap B$, $j \in A - B$</li>
</ol>

<p>Therefore, $z(\delta(A \cup B)) + z(\delta(A \cap B))$ will be sum of $z(e)$ in following 6 categories.</p>
<ol>
  <li>$i \in A - B$, $j \in V - (A \cup B)$</li>
  <li>$i \in A \cap B$, $j \in V - (A \cup B)$</li>
  <li>$i \in B - A$, $j \in V - (A \cup B)$</li>
  <li>$i \in A \cap B$, $j \in V - (A \cup B)$</li>
  <li>$i \in A \cap B$, $j \in B - A$</li>
  <li>$i \in A \cap B$, $j \in A - B$</li>
</ol>

<p>Now, we can do a mapping from this categories of $z(\delta(A \cup B)) + z(\delta(A \cap B))$ to one of 8 categories of $z(\delta(A)) + z(\delta(B))$.
$1 \rightarrow 1$, $2 \rightarrow 2$, $3 \rightarrow 5$, $4 \rightarrow 6$, $5 \rightarrow 4$, $6 \rightarrow 8.$
Now we have category 3, 7 lefts.
As a result, $z(\delta(A)) + z(\delta(B))$ $\ge$ $z(\delta(A \cup B)) + z(\delta(A \cap B))$.</p>

<p>Like above, we can do the same thing for $z(\delta(A)) + z(\delta(B))$ $\ge$ $z(\delta(A - B)) + z(\delta(B - A))$.</p>

<p>If you think about the category of edges in $\delta(A - B)$, it will be one of follows.</p>
<ol>
  <li>$i \in A - B$, $j \in V - (A \cup B)$</li>
  <li>$i \in A - B$, $j \in A \cap B$</li>
  <li>$i \in A - B$, $j \in B - A$</li>
</ol>

<p>If you think about the category of edges in $\delta(B - A)$, it will be one of follows.</p>
<ol>
  <li>$i \in B - A$, $j \in V - (A \cup B)$</li>
  <li>$i \in B - A$, $j \in A \cap B$</li>
  <li>$i \in B - A$, $j \in A - B$</li>
</ol>

<p>Therefore, $z(\delta(A - B)) + z(\delta(B - A))$ will be sum of $z(e)$ in following 6 categories.</p>
<ol>
  <li>$i \in A - B$, $j \in V - (A \cup B)$</li>
  <li>$i \in A - B$, $j \in A \cap B$ $\leftrightarrow$ $i \in A \cap B$, $j \in A - B$</li>
  <li>$i \in A - B$, $j \in B - A$</li>
  <li>$i \in B - A$, $j \in V - (A \cup B)$</li>
  <li>$i \in B - A$, $j \in A \cap B$ $\leftrightarrow$ $i \in A \cap B$, $j \in B - A$</li>
  <li>$i \in B - A$, $j \in A - B$</li>
</ol>

<p>We can map $1 \rightarrow 1$, $2 \rightarrow 8$, $3 \rightarrow 3$, $4 \rightarrow 5$, $5 \rightarrow 4$, $6 \rightarrow 7$.
Now we have category 2, 6 lefts.
As a result, $z(\delta(A)) + z(\delta(B))$ $\ge$ $z(\delta(A - B)) + z(\delta(B - A))$.</p>

<p>As a summary, both followings are true.</p>

<ol>
  <li>$z(\delta(A)) + z(\delta(B))$ $\ge$ $z(\delta(A \cup B)) + z(\delta(A \cap B))$</li>
  <li>$z(\delta(A)) + z(\delta(B))$ $\ge$ $z(\delta(A - B)) + z(\delta(B - A))$</li>
</ol>

<p>Now, let $z_F(e) = 1$ if $e \in F$ and $z_F(e) = 0$ otherwise.</p>

<p>Then, $f_i(S) = f(S) - |\delta(S) \cap F| = f(S) - z_F(\delta(S))$.
As a result $f_i(S)$ should fulfill one of follows.</p>
<ol>
  <li>$f_i(A)$ $+$ $f_i(B)$ $=$ $f(A)$ $+$ $f(B)$ $-$ $z_F(\delta(A))$ $-$ $z_F(\delta(B))$ $\le$ $f(A \cup B)$ $+$ $f(A \cap B)$ $-$ $z_F(\delta(A \cup B))$ $-$ $z_F(\delta(A \cap B))$ $=$ $f_i(A \cup B)$ $+$ $f_i(A \cap B)$.</li>
  <li>$f_i(A)$ $+$ $f_i(B)$ $=$ $f(A)$ $+$ $f(B)$ $-$ $z_F(\delta(A))$ $-$ $z_F(\delta(B))$ $\le$ $f(A - B)$ $+$ $f(B - A)$ $-$ $z_F(\delta(A - B))$ $-$ $z_F(\delta(B - A))$ $=$ $f_i(A - B)$ $+$ $f_i(B - A)$.</li>
</ol>

<p>Now, we showed that $f_i$ is a weakly supermodular.</p>

<p>Therefore, we can found at least one edge such that $x_e \ge \frac{1}{2}$ for any $f_i$.
Now if we can show that “Minimize $\sum\limits_{e \in E - F} c_e x_e$ such that $\sum\limits_{e \in \delta(S), e \in E - F} x_e \ge f_i(S) = f(S) - |\delta(S) \cap F|$ $\forall S \subset V$, $0 \le x_e \le 1$” can be solved in polynomial time, it will the end of the proof for polynomial execution time for the algorithm.
Notice that we can do this at most $O(\left\vert E \right\vert)$.</p>

<p>We still can use network flow algorithm to solve this.
Therefore, we will make a seperation orcale like below.</p>
<ol>
  <li>Make a graph that consists of $G = (V,E)$ and set capacity of $E - F$ as $x_e$ and capacity of $F$ as 1.</li>
  <li>Solve the network flow problem between all pair $i$ and $j$ such that $i \neq j$ and $i,j \in V$.</li>
  <li>If there is a flow such that the value of flow $f_{ij}$ is less than $r_{ij}$ then it’s an infeasible solution otherwise it is feasible.</li>
</ol>

<p>Notice that if it is feasible then it means $\sum\limits_{e \in \delta(S)} f_e + |\delta(S) \cap F| \ge r_{ij}$ which $\delta(S)$ denotes the set of edges between $S$ and $V - S$ in $E - F$.
As a result, $\sum\limits_{e \in \delta(S)} f_e \ge r_{ij} - |\delta(S) \cap F|$.
If there is some $i, j$ such that flow between $i$ and $j$ is less than $r_{ij}$ then there should be $S$ such that $\sum\limits_{e \in \delta(S)} f_e + |\delta(S) \cap F|&lt; r_{ij}$.
As a result, we can use this as a seperation orcale.</p>

<p>Now only left thing to show is that solution is in $2\operatorname{OPT}$.
To show this, we will prove generalized version of the claim.
The claim is 
“For any weakly supermodular function $f$, let’s define $x^i$ as the solution of LP in $i$th iteration.
If we can solve iterative rounding algorithm above in $k$ iteration then solution of iterative rounding $\operatorname{ANS}$ $=$ $\sum\limits_{e \in F} c_e$ is in $2\sum\limits_{e \in E} c_e x_e^1$”.
Notice that this implies $\operatorname{ANS}$ $=$ $\sum\limits_{e \in F} c_e$ $\le$ $2\sum\limits_{e \in E} c_e x_e^1$ $\le$ $2\operatorname{OPT}$.</p>

<p>We will show this in the inductive method.</p>

<p>If $k = 1$, we will solve “Minimize $\sum\limits_{e \in E} c_e x_e$ such that $\sum\limits_{e \in \delta(S), e \in E} x_e \ge f(S)$ $\forall S \subset V$, $0 \le x_e \le 1$” once and that’s all.
From the above, we will select $\{x_e : x_e \ge \frac{1}{2}\}$.
As a result, $\sum\limits_{e \in F_1} c_e$ $\le$ $2\sum\limits_{e \in F_1} c_e x_e^1$.</p>

<p>If $k \ge 2$, we have three facts follow.
First, $\sum\limits_{e \in F_1} c_e$ $\le$ $2\sum\limits_{e \in F_1} c_e x_e^1$ is true because we selected $x_e^1 \ge \frac{1}{2}$ in $x_e^1$.</p>

<p>Also, if we consider $\{x_e^1 | e \in E - F_1\}$ $=$ $\Lambda$ then $\Lambda$ is a feasible solution of LP in the second iteration either.
The reason is like follow.
Second constraint is trivial to be hold because $0 \le x_e^1 \le 1$.
First constraint holds either because of follows.
$\sum\limits_{e \in \delta(S), e \in E - F_1} x_e^1$ $=$ 
$\sum\limits_{e \in \delta(S), e \in E} x_e^1 - \sum\limits_{e \in \delta(S), e \in F_1} x_e^1$ $\ge$ 
$f_1(S) - |\delta(S) \cap F_1|$ $=$
$f_2(S)$.
Therefore, $\Lambda$ is a feasible solution.
As a result, $\sum\limits_{e \in E - F_1} c_e x_e^1$ $\ge$ $\sum\limits_{e \in E - F_1} c_e x_e^2$.</p>

<p>For the last, we can use iterative rounding for $E - F_1$ and $f_2(S)$ because it will terminted in $k - 1$ iterations.
Notice that we’ve proved that $f_2$ is a weakly supermodular.
As a result, $\sum\limits_{e \in F - F_1} c_e$ $\le$ $2\sum\limits_{e \in E - F_1} c_e x_e^2$.</p>

<p>In a summary, we have three facts.</p>
<ol>
  <li>$\sum\limits_{e \in F_1} c_e$ $\le$ $2\sum\limits_{e \in F_1} c_e x_e^1$</li>
  <li>$\sum\limits_{e \in E - F_1} c_e x_e^2$ $\le$ $\sum\limits_{e \in E - F_1} c_e x_e^1$</li>
  <li>$\sum\limits_{e \in F - F_1} c_e$ $\le$ $2\sum\limits_{e \in E - F_1} c_e x_e^2$.</li>
</ol>

<p>If we combine three facts above,
$\sum\limits_{e \in F} c_e$ $=$ 
$\sum\limits_{e \in F - F_1} c_e + \sum\limits_{e \in F_1} c_e$ $\le$ 
$2\sum\limits_{e \in E - F_1} c_e x_e^2 + 2\sum\limits_{e \in F_1} c_e x_e^1$ $\le$
$2\sum\limits_{e \in E - F_1} c_e x_e^1 + 2\sum\limits_{e \in F_1} c_e x_e^1$ $=$
$2\sum\limits_{e \in E} c_e x_e^1$.</p>

<p>Now proof stops here for survivable network design problem.</p>

<p>However, we need to show one following fact.
There exists an edge $e \in E$ such that $x_e \ge \frac{1}{2}$ if we solve linear problem “Minimize $\sum\limits_{e \in E} c_e x_e$ such that $\sum\limits_{e \in \delta(S)} x_e \ge f(S)$ $\forall S \subset V$, $0 \le x_e \le 1$” for any weakly supermodular $f$.</p>

<p>To show this proof, we need some definitions to make a proof.</p>

<ol>
  <li>$\chi_E$ is a vector such that $(\chi_E)_e$ $=$ $\cases{ 1, e \in E, x_e &gt; 0\cr 0, \text{otherwise}}$</li>
  <li>$A$ and $B$ are intersecting if all of $A \cap B$, $A - B$ and $B - A$ are not empty.</li>
  <li>$A$ is tight if $\sum\limits_{e \in \delta(A)} x_e = f(A)$ for $A \in V$.</li>
  <li>A collection of sets $\mathcal{L}$ is $\operatorname{laminor}$ if no pair of sets in $\mathcal{L}$ is intersecting.</li>
  <li>$\operatorname{Span}(\mathcal{L})$ $=$ $\operatorname{Span}\{\chi_{\delta(S)} \mid S \in \mathcal{L}\}$</li>
</ol>

<p>Now, we need some $\operatorname{Lemma}$s.</p>

<p>If $A$ and $B$ are tight and intersecting, at least one of the following is true.</p>
<ol>
  <li>$A \cap B$, $A \cup B$ are both tight and $\chi_{\delta(A \cap B)} + \chi_{\delta(A \cup B)}$ $=$ $\chi_{\delta(A)} + \chi_{\delta(B)}$</li>
  <li>$A - B$, $B - A$ are both tight and $\chi_{\delta(A - B)} + \chi_{\delta(B - A)}$ $=$ $\chi_{\delta(A)} + \chi_{\delta(B)}$</li>
</ol>

<p>Proof is like follow. one of $f(A) + f(B)$ $\le$ $f(A \cap B) + f(A \cup B)$ or $f(A) + f(B)$ $\le$ $f(A - B) + f(B - A)$ is true because $f$ is a weakly supermodular.
Then, there are two cases.
If we think about the first case, we can do a reasoning follow.
$\sum\limits_{e \in \delta(A \cap B)} x_e$ $+$ $\sum\limits_{e \in \delta(A \cup B)} x_e$ $\ge$ $f(A \cap B) + f(A \cup B)$ because of constraints of linear problem.
$f(A \cap B) + f(A \cup B)$ $\ge$ $f(A) + f(B)$ because $f$ is a weakly super modular.
$f(A) + f(B)$ $=$ $\sum\limits_{e \in \delta(A)} x_e$ $+$ $\sum\limits_{e \in \delta(B)} x_e$ becacuse $A$ and $B$ is tight.
As a result, $\sum\limits_{e \in \delta(A \cap B)} x_e$ $+$ $\sum\limits_{e \in \delta(A \cup B)} x_e$ $\ge$ $\sum\limits_{e \in \delta(A)} x_e$ $+$ $\sum\limits_{e \in \delta(B)} x_e$.</p>

<p>With this fact, $\sum\limits_{e \in \delta(A \cap B)} x_e$ $+$ $\sum\limits_{e \in \delta(A \cup B)} x_e$ $\ge$ $\sum\limits_{e \in \delta(A)} x_e$ $+$ $\sum\limits_{e \in \delta(B)} x_e$ $\ge$ $\sum\limits_{e \in \delta(A \cap B)} x_e$ $+$ $\sum\limits_{e \in \delta(A \cup B)} x_e$ if we use the fact follow “If we select $z(e) \ge 0$ for all $e \in E$ and define $z(E) = \sum\limits_{e \in E}z(e)$ then 
$z(\delta(A)) + z(\delta(B))$ $\ge$ $z(\delta(A \cup B)) + z(\delta(A \cap B))$ and $z(\delta(A)) + z(\delta(B))$ $\ge$ $z(\delta(A - B)) + z(\delta(B - A))$ for any $A, B \subset V$”.</p>

<p>As a result, 
$\sum\limits_{e \in \delta(A \cap B)} x_e$ $+$ $\sum\limits_{e \in \delta(A \cup B)} x_e$ $=$
$f(A \cap B) + f(A \cup B)$ $=$
$f(A) + f(B)$ $=$
$\sum\limits_{e \in \delta(A)} x_e$ $+$ $\sum\limits_{e \in \delta(B)} x_e$ $=$
$\sum\limits_{e \in \delta(A \cap B)} x_e$ $+$ $\sum\limits_{e \in \delta(A \cup B)} x_e$.
Which means that both $A \cap B$, $A \cup B$ are tight.
More over, if we recap the process of prooving the statement of $z$, there were 8 categories of edges and 2 are lefts in each cases.</p>

<ol>
  <li>$i \in A - B$, $j \in V - (A \cup B)$</li>
  <li>$i \in A \cap B$, $j \in V - (A \cup B)$</li>
  <li>$i \in A - B$, $j \in B - A$</li>
  <li>$i \in A \cap B$, $j \in B - A$</li>
  <li>$i \in B - A$, $j \in V - (A \cup B)$</li>
  <li>$i \in A \cap B$, $j \in V - (A \cup B)$</li>
  <li>$i \in B - A$, $j \in A - B$</li>
  <li>$i \in A \cap B$, $j \in A - B$</li>
</ol>

<p>Now we have category 2, 6 lefts for $\delta(A - B)$ and $\delta(B - A)$.
Similarly we have category 3, 7 lefts for $\delta(A \cup B)$ and $\delta(A \cap B)$.</p>

<p>However, $x_e$ for edges in category 2, 6 should be $0$ because $\sum\limits_{e \in \delta(A \cap B)} x_e$ $+$ $\sum\limits_{e \in \delta(A \cup B)} x_e$ $=$ $\sum\limits_{e \in \delta(A)} x_e$ $+$ $\sum\limits_{e \in \delta(B)} x_e$ and $0 \le x_e \le 1$. Then, we can know that $\delta(A \cap B)$, $\delta(A \cup B)$ and $\delta(A)$, $\delta(B)$ should have the same set of edges. As a result, $\chi_{\delta(A \cap B)} + \chi_{\delta(A \cup B)}$ $=$ $\chi_{\delta(A)} + \chi_{\delta(B)}$.</p>

<p>Simillarly, both $A - B$, $B - A$ are tight and $\chi_{\delta(A - B)} + \chi_{\delta(B - A)}$ $=$ $\chi_A + \chi_B$ should be hold in the second case.</p>

<p>Now, we will claim below with the lemma above.
Then, there is $\mathcal{L} \subset 2^{V}$ which satisfies 4 things.</p>
<ol>
  <li>$S$ is tight for all $S \in \mathcal{L}$</li>
  <li>$\{\chi_{\delta(S)}\}_{S \in \mathcal{L}}$ are linear independent.</li>
  <li>$\left\vert \mathcal{L} \right\vert$ $=$ $\left\vert E \right\vert$</li>
  <li>$\mathcal{L}$ is $\operatorname{laminor}$.</li>
</ol>

<p>Proof is like follow.
Let $\mathcal{T} \subset 2^{V}$ be the family of all tight sets and $\mathcal{L}$ as a maximal $\operatorname{laminor}$ subfamily of $\mathcal{T}$.
Which means $\mathcal{L}$ will not be a $\operatorname{laminor}$ if we add anything more to $\mathcal{L}$.</p>

<p>First, we will claim $\operatorname{Span}(\mathcal{T})$ $\subset$ $\operatorname{Span}(\mathcal{L})$ to show $\operatorname{Span}(\mathcal{T})$ $=$ $\operatorname{Span}(\mathcal{L})$.
Notice that $\operatorname{Span}(\mathcal{L})$ $\subset$ $\operatorname{Span}(\mathcal{T})$ is trivial because $\mathcal{L} \subset \mathcal{T}$.</p>

<p>Let’s assume not then there are some $S$ $\in$ $\mathcal{T}$ such that $\chi_{\delta(S)}$ $\not\in$ $\operatorname{Span}(\mathcal{L})$.
Between possible $S$s, let’s assume that we’ve choose $S$ such that $S$ has the fewest intersecting sets in $\mathcal{L}$.
However, $S$ should intersect with at least one set in $\mathcal{L}$.
The reason is that we can add $S$ to $\mathcal{L}$ because it doesn’t change $\mathcal{L}$ to be not $\operatorname{laminor}$ if it don’t intersect.
However, it’s contradiction to “$\mathcal{L}$ is maximal $\operatorname{laminor}$”.</p>

<p>Now, we can find $T \in \mathcal{L}$ such that $T$ is intersecting with $S$.
Then one of two need to be true because both $S$, $T$ are tight because $T \in \mathcal{L} \subset \mathcal{T}$ and $S \in \mathcal{T}$.</p>

<ol>
  <li>$S \cap T$, $S \cup T$ are both tight and $\chi_{\delta(S \cap T)} + \chi_{\delta(S \cup T)}$ $=$ $\chi_{\delta(S)} + \chi_{\delta(T)}$</li>
  <li>$S - T$, $T - S$ are both tight and $\chi_{\delta(S - T)} + \chi_{\delta(T - S)}$ $=$ $\chi_{\delta(S)} + \chi_{\delta(T)}$</li>
</ol>

<p>Let’s assume that it’s the case 1.
Then both $\chi_{\delta(S \cap T)}$, $\chi_{\delta(S \cup T)}$ can’t be in $\operatorname{Span}(\mathcal{L})$ at the same time.</p>

<p>Proof is like follow.
$\chi_{\delta(S)}$ $=$ $\chi_{\delta(S \cap T)}$ + $\chi_{\delta(S \cup T)}$ - $\chi_{\delta(T)}$ and $\chi_{\delta(S)}$ should be in $\operatorname{Span}(\mathcal{L})$ if $\chi_{\delta(S \cup T)}$, $\chi_{\delta(S \cap T)}$ are in $\operatorname{Span}(\mathcal{L})$ at the same time.
It’s the same of case 2 because $\chi_{\delta(S)}$ $=$ $\chi_{\delta(S - T)}$ + $\chi_{\delta(T)}$ - $\chi_{\delta(T - S)}$.</p>

<p>Now, let’s think about $X$ such that $\chi_{\delta(X)} \not\in \operatorname{Span}(\mathcal{L})$ and $X \in \{S \cap T, S \cup T\}$ in the first case or $\{S - T, T - S\}$ in the second case.
Then, $S$ and $Y$ are intersecting for any $Y \in \mathcal{L}$ such that $Y$ is intersecting with $X$.</p>

<p>Proof is like follow.
Notice that $Y$ should be one of three followings because $Y \in \mathcal{L}$, $T \in \mathcal{L}$.</p>
<ol>
  <li>$Y \cap T = \emptyset$</li>
  <li>$T - Y = \emptyset$</li>
  <li>$Y - T = \emptyset$</li>
</ol>

<p>Notice that all of followings are true.</p>
<ol>
  <li>$X \cap Y \neq \emptyset$</li>
  <li>$X - Y \neq \emptyset$</li>
  <li>$Y - X \neq \emptyset$</li>
  <li>$S \cap T \neq \emptyset$</li>
  <li>$S - T \neq \emptyset$</li>
  <li>$T - S \neq \emptyset$</li>
</ol>

<p>If $X = S \cap T$, $Y$ should fulfill one of three followings.</p>
<ol>
  <li>$Y \cap T = \emptyset$<br />
 $Y$ can’t intersect with $X$ because $Y \cap X$ $\subseteq$ $Y \cap T$ $=$ $\emptyset$.<br />
 Therefore, such $Y$ doesn’t exist.<br /></li>
  <li>$T - Y = \emptyset$<br />
 $Y$ can’t intersect with $X$ because $X - Y$ $\subseteq$ $T - Y$ $=$ $\emptyset$.<br />
 Therefore, such $Y$ doesn’t exist.<br /></li>
  <li>$Y - T = \emptyset$<br />
 $\emptyset$ $\neq$ $X \cap Y$ $\subseteq$ $S \cap Y$.<br />
 $\emptyset$ $\neq$ $X - Y$ $\subseteq$ $S - Y$.<br />
 $\emptyset$ $\neq$ $Y - X$ $=$ $Y - (S \cap T)$ $=$ $(Y - S)$ $\cup$ $(Y - T)$ $=$ $Y - S$.<br />
 As a result, $S$ intersects with $Y$.<br /></li>
</ol>

<p>If $X = S \cup T$, $Y$ should fulfill one of three followings.</p>
<ol>
  <li>$Y \cap T = \emptyset$<br />
 $\emptyset$ $\neq$ $X \cap Y$ $=$ $(S \cup T) \cap Y$ $=$ $(S \cap Y) \cup (T \cap Y)$ $=$ $S \cap Y$.<br />
 $\emptyset$ $\neq$ $S \cap T$ $=$ $(S \cap T) - (S \cap (T \cap Y))$ $=$ $(S \cap T) - ((S \cap T) \cap Y)$ $=$ $(S \cap T) - Y$ $\subseteq$ $((S \cap T) - Y) \cup ((S - T) - Y)$ $=$ $S - Y$.<br />
 $\emptyset$ $\neq$ $Y - X$ $\subseteq$ $Y - S$.<br />
 As a result, $S$ intersects with $Y$.<br /></li>
  <li>$T - Y = \emptyset$<br />
 $\emptyset$ $\neq$ $S \cap T$ $=$ $S \cap ((T \cap Y) \cup (T - Y))$ $=$ $S \cap (T \cap Y)$ $=$ $S \cap T \cap Y$ $=$ $(S \cap Y) \cap T$ $\subseteq$ $S \cap Y$.<br />
 $\emptyset$ $\neq$ $X - Y$ $=$ $(S \cup T) - Y$ $=$ $(S - Y) \cup (T - Y)$ $=$ $S - Y$.<br />
 $\emptyset$ $\neq$ $Y - X$ $\subseteq$ $Y - S$.<br />
 As a result, $S$ intersects with $Y$.<br /></li>
  <li>$Y - T = \emptyset$<br />
 $Y$ can’t intersect with $X$ because $Y - X$ $\subseteq$ $Y - T$ $=$ $\emptyset$.<br />
 Therefore, such $Y$ doesn’t exist.<br /></li>
</ol>

<p>If $X = S - T$, $Y$ should fulfill one of three followings.<br /></p>
<ol>
  <li>$Y \cap T = \emptyset$<br />
 $\emptyset$ $\neq$ $X \cap Y$ $=$ $(S - T) \cap Y$ $\subseteq$ $S \cap Y$.<br />
 $\emptyset$ $\neq$ $X - Y$ $\subseteq$ $S - Y$.<br />
 $\emptyset$ $\neq$ $Y - X$ $=$ $Y - (S - T)$ $=$ $Y - (Y \cap (S - T))$ $=$ $Y - ((Y \cap S) - (Y \cap T))$ $=$ $Y - (Y \cap S)$ $=$ $Y - S$.<br />
 As a result, $S$ intersects with $Y$.<br /></li>
  <li>$T - Y = \emptyset$<br />
 $\emptyset$ $\neq$ $X \cap Y$ $=$ $(S - T) \cap Y$ $=$ $(S \cap  Y) - (T \cap Y)$ $\subseteq$ $S \cap Y$.<br />
 $\emptyset$ $\neq$ $X - Y$ $\subseteq$ $S - Y$.<br />
 $\emptyset$ $\neq$ $T - S$ $\subseteq$  $(Y \cup T) - S$ $=$ $(Y \cup (T - Y)) - S$ $=$ $(Y - S) \cup ((T - Y) - S)$ $=$ $Y - S$.<br />
 As a result, $S$ intersects with $Y$.<br /></li>
  <li>$Y - T = \emptyset$<br />
 $Y$ can’t intersect with $X$ because $X \cap Y$ $=$ $(S - T) \cap Y$ $=$ $(S \cap Y) - (T \cap Y)$ $=$ $(S \cap Y) - ((T \cap Y) \cup (Y - T))$ $\subseteq$ $((S \cap Y) \cup (Y - S)) - ((T \cap Y) \cup (Y - T))$ $=$ $Y - Y$ $=$ $\emptyset$.<br />
 Therefore, such $Y$ doesn’t exist.<br /></li>
</ol>

<p>If $X = T - S$, $Y$ should fulfill one of three followings.</p>
<ol>
  <li>$Y \cap T = \emptyset$<br />
 $Y$ can’t intersect with $X$ because $X \cap Y$ $=$ $(T - S) \cap Y$ $\subseteq$ $T \cap Y$ $=$ $\emptyset$.<br />
 Therefore, such $Y$ doesn’t exist.<br /></li>
  <li>$T - Y = \emptyset$<br />
 $Y$ can’t intersect with $X$ because $X - Y$ $=$ $(T - S) - Y$ $\subseteq$ $T - Y$ $=$ $\emptyset$.<br />
 Therefore, such $Y$ doesn’t exist.<br /></li>
  <li>$Y - T = \emptyset$<br />
 $\emptyset$ $\neq$ $Y - X$ $=$ $Y - (T - S)$ $=$ $Y - ((T \cup (Y - T)) - S)$ $=$ $Y - ((Y \cup T) - S)$ $=$ $Y - ((Y \cup (T - Y)) - S)$ $\subseteq$ $Y - (Y - S)$ $=$ $S \cap Y$.<br />
 $\emptyset$ $\neq$ $S - T$ $=$ $S - (T \cup (Y - T))$ $=$ $S - (Y \cup T)$ $=$ $S - (Y \cup (T - Y))$ $\subseteq$ $S - Y$.<br />
 $\emptyset$ $\neq$ $X \cap Y$ $=$ $(T - S) \cap Y$ $=$ $(T - (S \cap T)) \cap Y$ $=$ $(T \cap Y) - ((S \cap T) \cap Y)$ $=$ $(T \cap Y) - (S \cap (T \cap Y))$ $=$ $(T \cap Y) - S$ $=$ $((T \cap Y) \cup (Y - T)) - S$ $=$ $Y - S$.<br />
 As a result, $S$ intersects with $Y$.<br /></li>
</ol>

<p>As a result, $S$ and $Y$ are intersecting for any $Y \in \mathcal{L}$ such that $Y$ is intersecting with $X$.</p>

<p>Now, let’s think about $X$.
Then, $X$ should have strictly fewer intersecting sets with $\mathcal{L}$ than $S$.
The reason is like follow.
If $X$ is intersecting with $Y \in \mathcal{L}$ then, $S$ does so either.
However, there is at least one set such that intersects with $S$ but not with $X$ which is $T$.
Notice that $X \in \{S \cap T, S \cup T, S - T, T - S\}$ and
$(S \cap T) - T = \emptyset$,
$T - (S \cup T) = \emptyset$,
$(S - T) \cap T = \emptyset$,
$(T - S) - T= \emptyset$.
However, this is contradiction that we’ve choosed $S$ such that has $S$ has the fewest intersecting sets in $\mathcal{L}$.</p>

<p>Therefore, such an $S$ can’t exists and $\operatorname{Span}(\mathcal{T})$ $=$ $\operatorname{Span}(\mathcal{L})$ is true.
Now, we’ve showend that there is at least one of a maximal $\operatorname{laminor}$ subfamily of $\mathcal{T}$ namely $\mathcal{L}$ such that fulfills following two.</p>
<ol>
  <li>$S$ is tight for all $S \in \mathcal{L}$</li>
  <li>$\mathcal{L}$ is $\operatorname{laminor}$.</li>
</ol>

<p>Now, we can find some set $S \in \mathcal{T}$ which is lineary dependent from other vectors.
Then, we can just remove it without losing property above.
Now, we keep doing it untill every vectors are lineary independent and let the result to be $\mathcal{L}^\star$.
Then, $\mathcal{L}^\star$ should have $\left\vert E \right\vert$ independent vectors because they are all independent and $\operatorname{Span}(\mathcal{L}^\star)$ Should be still $\operatorname{Span}(\mathcal{T})$ because we removed only lineary dependent vectors.
Notice that each vector has $\left\vert E \right\vert$ elements inside.
Therefore, $\mathcal{L}^\star$ fulfills every property below.</p>
<ol>
  <li>$S$ is tight for all $S \in \mathcal{L}^\star$</li>
  <li>$\{\chi_{\delta(S)}\}_{S \in \mathcal{L}^\star}$ are linear independent.</li>
  <li>$\left\vert \mathcal{L}^\star \right\vert$ $=$ $\left\vert E \right\vert$</li>
  <li>$\mathcal{L}^\star$ is $\operatorname{laminor}$.</li>
</ol>

<p>Now, we will show the following is true.</p>

<p>There exists an edge $e \in E$ such that $x_e \ge \frac{1}{2}$ if we solve linear problem “Minimize $\sum\limits_{e \in E} c_e x_e$ such that $\sum\limits_{e \in \delta(S)} x_e \ge f(S)$ $\forall S \subset V$, $0 \le x_e \le 1$” for any weakly supermodular $f$.</p>

<p>To show this, let’s think about such an $\mathcal{L}$ satisfies 4 properties from given LP and let’s assume that $0 &lt; x_e &lt; \frac{1}{2}$ for all $e \in E$.
Now, let’s define set $A$ is bigger than $B$ when $B \subset A$.
Then we can construct a forest since $\mathcal{L}$ is a $\operatorname{laminor}$.
Notice that one of following should be true for $X, Y \in \mathcal{L}$.</p>
<ol>
  <li>$X \cap Y$ $=$ $\emptyset$</li>
  <li>$X - Y$ $=$ $\emptyset$ $\leftrightarrow$ $X \subseteq Y$</li>
  <li>$Y - X$ $=$ $\emptyset$ $\leftrightarrow$ $Y \subseteq X$</li>
</ol>

<p>From the fact above, we will construct a forest like follow.</p>

<ol>
  <li>Select biggest sets in $\mathcal{L}$ and make them to the roots.</li>
  <li>Select biggest sets in $S$ for any root $S$ and make them to child of $S$.</li>
  <li>Keep do this recursively untill every set is in the forest.</li>
</ol>

<p>Notice that $X$ is the child of $S$ if and only if there is no set $Y$ exists such that $Y$ is the child of $S$ but $X$ is child of $Y$ either.
It means there is no double depth child relation.</p>

<p>With this $\mathcal{L}$, we can pass some costs to the sets.
Let’s pass the costs like follow.</p>

<ol>
  <li>Pass $x_e$ to set $X$ if $u$ or $v$ is in $X$ and $X$ is the smallest set among such sets for any edge $e = (u,v)$.</li>
  <li>Pass $1 - 2x_e$ to set $X$ if both $u$ and $v$ are in $X$ and $X$ is the smallest set among such sets for any edge $e = (u,v)$.</li>
</ol>

<p>Then, select a root of forest $S$.
With this $S$, let’s define child of $S$ as $C_1, C_2, \cdots, C_n$ and $C = \bigcup\limits_{k = 1}^{n} C_k$.
Then, we can define 4 categories for edge $e \in (\delta(S) \cup \delta(C))$.</p>

<ol>
  <li>$E_{cc}$ is the set of edges $e \in E$ such that one end point of edge is in $C_i$ and other is in $C_j$ for $i \neq j$.</li>
  <li>$E_{cp}$ is the set of edges $e \in E$ such that one end point of edge is in $C_i$ and other is in $S - C$.</li>
  <li>$E_{co}$ is the set of edges $e \in E$ such that one end point of edge is in $C_i$ and other is in $V - S$.</li>
  <li>$E_{po}$ is the set of edges $e \in E$ such that one end point of edge is in $S - C$ and other is in $V - S$.</li>
</ol>

<p>If we count every cost gain for $S$ from each categories, it is like follow.</p>

<ol>
  <li>$1 - 2x_e$ from $E_{cc}$.</li>
  <li>$1 - 2x_e + x_e = 1 - x_e$ from $E_{cp}$.</li>
  <li>Nothing from $E_{co}$.</li>
  <li>$x_e$ from $E_{po}$.</li>
</ol>

<p>Then, the total costs $S$ gain is $\left\vert E_{cc} \right\vert$ $-$ $2x(E_{cc})$ $+$ $\left\vert E_{cp} \right\vert$ $-$ $x(E_{cp})$ $+$ $x(E_{po})$ $=$ $\left\vert E_{cc}\right\vert$ $+$ $\left\vert E_{cp} \right\vert$ $-$ $2x(E_{cc})$ $-$ $x(E_{cp})$ $+$ $x(E_{po})$.</p>

<p>Notice that $E_{cc} \cup E_{cp} \cup E_{po} \neq \emptyset$.
Proof is like follow.</p>

<p>Let’s assume not then $E_{cc} = E_{cp} = E_{po} = \emptyset$.
Which means $x(\delta(S))$ $=$ $x(E_{po} + E_{co})$ $=$ $x(E_{co})$ $=$ $x(E_{co} \cup E_{cc} \cup E_{cp})$ $=$ $x(\delta(C))$ $=$ $x(\delta(\bigcup\limits_{k = 1}^{n} C_k))$ $=$ $\sum\limits_{k = 1}^n x(\delta(C_k))$ because $C_i \cap C_j = \emptyset$.
Notice that $C_i$ is the sibling of $C_j$ in the forest.
However, $x(\delta(S))$ $=$ $\sum\limits_{k = 1}^n x(\delta(C_k))$ can’t be true because it’s a contradiction for the fact that $\chi_{\delta(S)}$, $\chi_{\delta(C_1)}$, $\cdots$, $\chi_{\delta(C_n)}$ are linear independent.
Therefore, $\left\vert E_{cc} \right\vert$ $-$ $2x(E_{cc})$ $+$ $\left\vert E_{cp} \right\vert$ $-$ $x(E_{cp})$ $+$ $x(E_{po})$ $&gt;$ $0$.
Notice that every value is positive because we assumed $0 &lt; x_e &lt; \frac{1}{2}$.</p>

<p>Now, let’s think about the categories of edges for $E_{cc}, E_{cp}, E_{po}$.
Then $x(\delta(S))$ $=$ $x(E_{po})$ $+$ $x(E_{co})$ and $x(\delta(C))$ $=$ $x(E_{cp})$ $+$ $2x(E_{cc})$ $+$ $x(E_{co})$.
Reason is like follow.</p>

<ol>
  <li>For $\delta(S)$, all the edges should be one of $E_{co}$ or $E_{po}$ because one of end point should be in $V - S$.</li>
  <li>For $\delta(C)$, there are three type of edges like just described.
 One for from $C_i$ to $V - S$.
 One for from $C_i$ to $S - C$.
 One for from $C_i$ to $C_j$ for $i \neq j$.
 However, $x(\delta(C))$ will count twice for “One for from $C_i$ to $C_j$ for $i \neq j$”.</li>
</ol>

<p>As a result, $\left\vert E_{cc} \right\vert$ $+$ $\left\vert E_{cp} \right\vert$ $-$ $2x(E_{cc})$ $-$ $x(E_{cp})$ $+$ $x(E_{po})$ $=$ $\left\vert E_{cc} \right\vert$ $+$ $\left\vert E_{cp} \right\vert$ $+$ $x(E_{po})$ $+$ $x(E_{co})$ $-$ $(x(E_{cp}) + 2x(E_{cc}) + x(E_{co}))$
$=$ $\left\vert E_{cc} \right\vert$ $+$ $\left\vert E_{cp} \right\vert$ $+$ $x(\delta(S))$ $-$ $x(\delta(C))$.
However, $\left\vert E_{cc} \right\vert$ $+$ $\left\vert E_{cp} \right\vert$ $+$ $x(\delta(S))$ $-$ $x(\delta(C))$ should be an integer because all of elements in the equation are intergers.
Therefore, each $S$ should have at least 1 costs.
Which means total cost of $\mathcal{L}$ $\ge$ $\left\vert E \right\vert$ since $\left\vert \mathcal{L} \right\vert$ $=$ $\left\vert E \right\vert$.
However, total cost of $\mathcal{L}$ $&lt;$ $\left\vert E \right\vert$ is true because of following reasons.</p>

<p>Each edge passes at most $x_e + x_e + (1 - 2x_e) = 1$ cost to sets.
Therefore, total cost of $\mathcal{L} \le \left\vert E \right\vert$.
However, there is at least one edge that outgoing of $S$.
If there is no such an edge, $S$ should contain every vertices and it means $S = V$.
However if so, $\delta(S) = \emptyset$ because there is no edge between $S$ and $S - V = V - V = \emptyset$.
Which means $S$ can’t be in $\mathcal{L}$ because $\chi_{\delta(S)} = \vec{0}$ can’t be the vector in the lineary indepdendent set.
As a result, total cost of $\mathcal{L} &lt; \left\vert E \right\vert$.</p>

<p>Therefore, it’s a contradiction with the fact above.
As a result, assumption that “$0 &lt; x_e &lt; \frac{1}{2}$ for all $e \in E$” is false.
Therefore, there should be at least $x_e$ shuch that $x_e \ge \frac{1}{2}$ or $x_e = 0$.
However, if we think about the LP with removing $x_e$s such that $x_e = 0$ then solution of problem should be the same with before.
At the same time, there should be at least one $x_e$ such that $x_e \ge \frac{1}{2}$ or $x_e = 0$.
However, that should be the case of $x_e \ge \frac{1}{2}$ because we just removed every $x_e = 0$.
Therefore, claim holds.</p>


      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>
    
    <div class="references">
      
        
          <p class="reference"><strong>Reference :</strong>David P. Williamson and David B. Shmoys, The Design of Approximation Algorithms</p>
        
          <p class="reference"><strong>Reference :</strong>CSI6107 lecture at Yonsei University</p>
        
      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            
            <a href="/tag/#/algorithm" rel="tag"># algorithm</a>
          
            
            <a href="/tag/#/approximation" rel="tag"># approximation</a>
          
        </div>
      

      
      
      
      
      

      
      
        <div class="post-nav" id="post-nav-id">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2021/04/20/LP-Duality/" rel="next" title="LP Duality">
                <i class="fa fa-chevron-left"></i> LP Duality
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2021/04/04/Approximation-algorithm(8)/" rel="prev" title="Approximation algorithm(8) - Integer multicommodity flows">
                Approximation algorithm(8) - Integer multicommodity flows <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      
      

      
    </footer>
  </article>
  <div class="post-spread">
    
  </div>
</div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          


  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      
        
        
        







      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/assets/images/avatar.gif"
               alt="Programelot" />
          <p class="site-author-name" itemprop="name">Programelot</p>
           
              <p class="site-description motion-element" itemprop="description">I am Programelot who is researching about optimization.</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">39</span>
                <span class="site-state-item-name">posts</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/">
                <span class="site-state-item-count">10</span>
                <span class="site-state-item-name">tags</span>
              </a>
            </div>
          

        </nav>

        
        
        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>

        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Programelot</span>
</div>


<div class="powered-by">
  Powered by <a class="theme-link" href="https://jekyllrb.com">Jekyll</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/simpleyyt/jekyll-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>





















  
   
  
  
  
  
  
  <script type="text/javascript" src="/assets/lib/jquery/index.js?v=2.1.3"></script>

  
  
  
  
  
  <script type="text/javascript" src="/assets/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  
  
  
  
  <script type="text/javascript" src="/assets/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  
  
  
  
  <script type="text/javascript" src="/assets/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  
  
  
  
  <script type="text/javascript" src="/assets/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  
  
  
  
  <script type="text/javascript" src="/assets/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/assets/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/assets/js/src/motion.js?v=5.1.1"></script>



  
  

  <script type="text/javascript" src="/assets/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/assets/js/src/post-details.js?v=5.1.1"></script>


  


  <script type="text/javascript" src="/assets/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  











  




  

    

  







  


  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  
  


  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>

