<head></head>
<body>
    <center>
        <button onclick="init()">Initilize</button>
        <button onclick="compute()">Compute</button>
        <br>
        <canvas id="canvas1" width="200" height="150" style="border:1px solid #d3d3d3;">
            Your browser does not support the HTML canvas tag.</canvas>
        <canvas id="canvas2" width="200" height="150" style="border:1px solid #d3d3d3;">
            Your browser does not support the HTML canvas tag.</canvas>
        <br>
        <textarea id="form" rows="10" cols="20" onkeyup="saveMemo()" style="margin: 0px;  width: 300px;">Use initialization to get some examples</textarea>
    </center>
    <script language = "javascript">
        const loadedToDos = localStorage.getItem('formFile_banRamlo');  
        if (loadedToDos !== null) {
            document.getElementById("form").value = JSON.parse(localStorage['formFile_banRamlo'])['form'];
        }
        function saveMemo() {
            let formFile = {'form':document.getElementById("form").value};
            localStorage['formFile_banRamlo'] = JSON.stringify(formFile);
        }

        function init(){
            if(confirm("Do you want to init the fomula?")){
                document.getElementById("form").value = "//Bases are S0,S1,S2,U\n//Declare new variable\nV = S0\n//Assigning variable\n//* is an intersection\nI = V*S1\nJ = S1*S2\nK = S2*V\n//- is a difference//+ is an union\nR = U - (I + J + K)\n\n//Print result 1\nprint1 I\n//Print result 2\nprint2 R + S0*S1*S2";
                saveMemo();
            }
        }

        var maxPrint = 2;
        var setNum = 3;
        var distinctElementNum = Math.pow(2,setNum);
        var baseName = [];
        for(let i = 0; i < setNum; ++i){
            baseName.push("S" + (i));
        }
        baseName.push("U");

        ///////////////////////////////
        //  Types
        ///////////////////////////////
        //  Variable
        //  Op
        //  Print
        //  Parenthesis
        //  EOL
        ///////////////////////////////
        class Token{
            constructor() {
                this.type = "";
                this.data = "";
            }

            setType(data){
                this.type = data;
            }
            
            setData(data){
                this.data = data;
            }

            readType(){
                return this.type;
            }

            readData(){
                return this.data;
            }
        };

        ///////////////////////////////
        //  Types
        ///////////////////////////////
        // State
        // Op
        // Print
        // Variable
        ///////////////////////////////
        class AST {
            constructor(type) {
                this.type = type;
                this.data = "";
                this.left = null;
                this.right = null;
            }
            addLeft(left){
                this.left = left;
            }
            addRight(right){
                this.right = right;
            }

            readLeft(){
                return this.left;
            }
            readRight(){
                return this.right;
            }

            setData(data){
                this.data = data;
            }

            readData(){
                return this.data;
            }
            readType(){
                return this.type;
            }

            evaluate(map){
                let l, r;
                l = this.readLeft();
                r = this.readRight();
                
                if(this.readType() == "State"){
                    //Pass nothing to be done
                    if(l != null)
                        [,map] = l.evaluate(map);
                    if(r != null)
                        [,map] = r.evaluate(map);
                    return [null, map];
                }
                else if(this.readType() == "Op"){
                    //Operation
                    switch(this.readData()){
                        case '+':
                            {  
                                let ret = [];
                                [l, map] = l.evaluate(map);
                                [r, map] = r.evaluate(map);
                                for(let i = 0; i < distinctElementNum; ++i){
                                    if(l[i] || r[i])
                                        ret.push(1);
                                    else
                                        ret.push(0);
                                }
                                return [ret, map];
                            }
                        case '-':
                            {  
                                let ret = [];
                                [l, map] = l.evaluate(map);
                                [r, map] = r.evaluate(map);
                                for(let i = 0; i < distinctElementNum; ++i){
                                    if(l[i] && (!r[i]))
                                        ret.push(1);
                                    else
                                        ret.push(0);
                                }
                                return [ret, map];
                            }
                        case '*':
                            {  
                                let ret = [];
                                [l, map] = l.evaluate(map);
                                [r, map] = r.evaluate(map);
                                for(let i = 0; i < distinctElementNum; ++i){
                                    if(l[i] && r[i])
                                        ret.push(1);
                                    else
                                        ret.push(0);
                                }
                                return [ret, map];
                            }
                        case '=':
                            {
                                [r, map] = r.evaluate(map);
                                if(map.has(l.readData()))
                                    throw "No variable redeclaration"
                                map.set(l.readData(), r);
                                return [null, map];
                            }
                        default:
                            throw "Evaluation error";
                    }
                }
                else if(this.readType() == "Print"){
                    //Operation
                    let val = this.readData();
                    let c = document.getElementById("canvas" + val);
                    let printTarget;
                    [printTarget, map] = l.evaluate(map);
                    if(c != null){
                        let ctx = c.getContext("2d");
                        //Draw
                        //fill in
                        if(printTarget[0]){ // U
                            ctx.fillStyle = "orange";
                        }
                        else{
                            ctx.fillStyle = "white";
                        }
                        ctx.fillRect(0, 0, 200, 150);

                        if(printTarget[1]){ //A
                            ctx.fillStyle = "orange";
                        }
                        else{
                            ctx.fillStyle = "white";
                        }
                        ctx.beginPath();
                        ctx.arc(100,55,40, 0,2*Math.PI);
                        ctx.fill();
                        ctx.stroke();

                        if(printTarget[2]){//B
                            ctx.fillStyle = "orange";
                        }
                        else{
                            ctx.fillStyle = "white";
                        }
                        ctx.beginPath();
                        ctx.arc(75,100,40, 0,2*Math.PI);
                        ctx.fill();
                        ctx.stroke();

                        if(printTarget[4]){//C
                            ctx.fillStyle = "orange";
                        }
                        else{
                            ctx.fillStyle = "white";
                        }
                        ctx.beginPath();
                        ctx.arc(125,100,40, 0,2*Math.PI);
                        ctx.fill();
                        ctx.stroke();

                        if(printTarget[3]){//A*B
                            ctx.fillStyle = "orange";
                        }
                        else{
                            ctx.fillStyle = "white";
                        }
                        ctx.beginPath();
                        ctx.arc(100,55,40, 1.15,3);
                        ctx.fill();
                        ctx.stroke();

                        ctx.beginPath();
                        ctx.arc(75,100,40, 4.3,6.1);
                        ctx.fill();
                        ctx.stroke();

                        if(printTarget[5]){//A*C
                            ctx.fillStyle = "orange";
                        }
                        else{
                            ctx.fillStyle = "white";
                        }
                        ctx.beginPath();
                        ctx.arc(100,55,40, 0.2,2);
                        ctx.fill();
                        ctx.stroke();

                        ctx.beginPath();
                        ctx.arc(125,100,40, 3.3,5.1);
                        ctx.fill();
                        ctx.stroke();

                        if(printTarget[6]){//B*C
                            ctx.fillStyle = "orange";
                        }
                        else{
                            ctx.fillStyle = "white";
                        }
                        ctx.beginPath();
                        ctx.arc(75,100,40, -0.9,0.9);
                        ctx.fill();
                        ctx.stroke();

                        ctx.beginPath();
                        ctx.arc(125,100,40, 2.25,4.1);
                        ctx.fill();
                        ctx.stroke();

                        if(printTarget[7]){//A*B*C
                            ctx.fillStyle = "orange";
                        }
                        else{
                            ctx.fillStyle = "white";
                        }
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.arc(125,100,40, 3.25,4.1);
                        ctx.fill();
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.arc(75,100,40, -1,-0.1);
                        ctx.fill();
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.arc(100,55,40, 1.1,2);
                        ctx.fill();
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.moveTo(85, 92);
                        ctx.lineTo(115, 92);
                        ctx.lineTo(100, 70);
                        ctx.fill();


                        //Border
                        ctx.beginPath();
                        ctx.arc(100,55,40, 0,2*Math.PI);
                        ctx.stroke();

                        ctx.beginPath();
                        ctx.arc(75,100,40, 0,2*Math.PI);
                        ctx.stroke();

                        ctx.beginPath();
                        ctx.arc(125,100,40, 0,2*Math.PI);
                        ctx.stroke();

                        //Text
                        ctx.textAlign = "center";
                        ctx.fillStyle = "red";
                        ctx.font = "20px Arial";
                        ctx.fillText(baseName[0], 100, 20);
                        ctx.fillText(baseName[1], 40, 130);
                        ctx.fillText(baseName[2], 160, 130);
                    }
                    return [null, map];
                }
                else if(this.readType() == "Variable"){
                    return [map.get(this.readData()), map];
                }
                throw "Evaluation error";
            }
        }

        function isNumber(str){
            if(typeof str != "string")
                return false;
            return !isNaN(str)
        }

        function scan(codes){
            let tokens = [];
            let pos = 0;
            while(true){
                if(('a' <= codes[pos] && codes[pos] <= 'z') || ('A' <= codes[pos] && codes[pos] <= 'Z')){
                    let fromPos = pos;
                    pos += 1;
                    while((pos < codes.length) && (('a' <= codes[pos] && codes[pos] <= 'z') || ('A' <= codes[pos] && codes[pos] <= 'Z') || ('0' <= codes[pos] && codes[pos] <= '9')))
                        pos += 1;
                    let token = new Token();
                    token.type = "Variable";
                    token.data = codes.substring(fromPos, pos);
                    if(token.data.startsWith("print") && isNumber(token.data.substring(5))){
                        token.type = "Print";
                        token.data = token.data.substring(5);
                    }
                    tokens.push(token);
                }
                else if((codes[pos] == '+') || (codes[pos] == '-') || (codes[pos] == '*')|| (codes[pos] == '=')){
                    let token = new Token();
                    token.type = "Op";
                    token.data = codes.substring(pos, pos + 1);
                    tokens.push(token);
                    pos += 1;
                }
                else if(codes[pos] == '(' || codes[pos] == ')'){
                    let token = new Token();
                    token.type = "Parenthesis";
                    token.data = codes.substring(pos, pos + 1);
                    tokens.push(token);
                    pos += 1;
                }
                else if(codes[pos] == "/"){
                    pos += 1;
                    if(codes[pos] == "/"){
                        pos += 1;
                        while((pos < codes.length) && (codes[pos] != '\n'))
                            pos += 1;
                        pos += 1;
                    }
                    else{
                        throw "Wrong scanner result";
                    }
                }
                else if((codes[pos] == " ") || (codes[pos] == "\t")){
                    pos += 1;
                }
                else if(codes[pos] == "\n"){
                    if((tokens.length > 0) && (tokens[tokens.length - 1].readType() != "EOL")){
                        let token = new Token();
                        token.type = "EOL";
                        token.data = codes.substring(pos, pos + 1);
                        tokens.push(token);
                    }
                    pos += 1;
                }
                else{
                    throw "Wrong scanner result " + codes[pos];
                }
                if(codes.length <= pos){
                    break;
                }
            }
            return tokens;
        }

        function check(required, tokens, pos){
            if((tokens.length > pos) && (tokens[pos].readType() == required))
                return true;
            return false;
        }

        function check_detail(requiredType, requiredData, tokens, pos){
            if((tokens.length > pos) && (tokens[pos].readType() == requiredType) && (tokens[pos].readData() == requiredData))
                return true;
            return false;
        }

		function parse(tokens, pos){
            let l, r;
            l = null;
            [l, pos] = parseStatement(tokens, pos);
            if(check("EOL", tokens, pos)){
                pos += 1;
                [r, pos] = parse(tokens, pos);
                let ret = new AST("State");
                ret.addLeft(l);
                ret.addRight(r);
                return [ret, pos];
            }
            return [l, pos];
        }

        function parseStatement(tokens, pos){
            let l, r;
            if(tokens.length <= pos){
                return [null, pos]; //Lambda case 1
            }
            else if(check("Variable", tokens, pos)){
                return parseDeclaration(tokens, pos);
            }
            else if(check("Print", tokens, pos)){
                return parsePrint(tokens, pos);
            }
            else{
                return [null, pos]; //Lambda case 2
            }
        }

        function parseDeclaration(tokens, pos){
            let l, r;
            [l, pos] = parseVariable(tokens, pos);
            if(!check_detail("Op", "=", tokens, pos)){
                throw "Parser error";
            }
            pos += 1;
            [r, pos] = parseEXP_Diff(tokens, pos);
            let ret = new AST("Op");
            ret.setData("=");
            ret.addLeft(l);
            ret.addRight(r);
            return [ret, pos];
        }

        function parsePrint(tokens, pos){
            let ret = new AST("Print");
            if(!check("Print", tokens, pos)){
                throw "Parser error";
            }
            ret.setData(tokens[pos].readData());
            pos += 1;
            [l, pos] = parseEXP_Diff(tokens, pos);
            ret.addLeft(l);
            return [ret, pos];
        }
        
        function parseEXP_Diff(tokens, pos){
            let l, r;
            [l, pos] = parseEXP_Uni(tokens, pos);
            if(check_detail("Op", "-", tokens, pos)){
                let ret = new AST("Op");
                ret.setData("-");
                pos += 1;
                [r, pos] = parseEXP_Diff(tokens, pos);
                ret.addLeft(l);
                ret.addRight(r);
                return [ret, pos];
            }
            return [l, pos];
        }
             
        function parseEXP_Uni(tokens, pos){
            let l, r, ret;
            [ret, pos] = parseEXP_Inter(tokens, pos);
            while(check_detail("Op", "+", tokens, pos)){
                l = ret;
                ret = new AST("Op");
                ret.setData(tokens[pos].readData());
                pos += 1;
                [r, pos] = parseEXP_Inter(tokens, pos);
                ret.addLeft(l);
                ret.addRight(r);
            }
            return [ret, pos];
        }

        function parseEXP_Inter(tokens, pos){
            let l, r;
            [l, pos] = parseEXP_PT(tokens, pos);
            if(check_detail("Op", "*", tokens, pos)){
                let ret = new AST("Op");
                ret.setData("*");
                pos += 1;
                [r, pos] = parseEXP_Inter(tokens, pos);
                ret.addLeft(l);
                ret.addRight(r);
                return [ret, pos];
            }
            return [l, pos];
        }
        
        function parseEXP_PT(tokens, pos){
            if(check_detail("Parenthesis", "(", tokens, pos)){
                pos += 1;
                let ret;
                [ret, pos] = parseEXP_Diff(tokens, pos);
                if(!check_detail("Parenthesis", ")", tokens, pos)){
                    throw "Parser Error";
                }
                pos += 1;
                return [ret, pos];
            }
            return parseVariable(tokens, pos);
        }

        function parseVariable(tokens, pos){
            if(!check("Variable", tokens, pos)){
                throw "Parser Error";
            }
            let ret = new AST("Variable");
            ret.setData(tokens[pos].readData());
            pos += 1;
            return [ret, pos];
        }

        function compute(){
            let codes = document.getElementById("form").value;
            let tokens = scan(codes);
            let ast = parse(tokens, 0)[0];
            
            let map = new Map();

            //Each sets
            for(let i = 0; i < setNum; ++i){
                let v = 1 << i;
                let lst = [];
                for(let j = 0; j < distinctElementNum; ++j){
                    if(j & v){
                        lst.push(1);
                    }
                    else{
                        lst.push(0);
                    }
                }
                map.set(baseName[i], lst);
            }

            {//Universe set   
                let lst = [];
                for(let j = 0; j < distinctElementNum; ++j){
                    lst.push(1);
                }
                map.set("U", lst);
            }
            
            for(let i = 0; i < maxPrint; ++i){
                let c = document.getElementById("canvas" + (i + 1));
                if(c != null){
                    let ctx = c.getContext("2d");
                    ctx.fillStyle = "white";
                    ctx.fillRect(0, 0, c.width, c.height);
                }
            }
            ast.evaluate(map);
        }
    </script>
</body>