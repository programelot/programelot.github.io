<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.7.4">Jekyll</generator><link href="https://programelot.github.io/atom.xml" rel="self" type="application/atom+xml" /><link href="https://programelot.github.io/" rel="alternate" type="text/html" /><updated>2023-01-20T03:46:19+09:00</updated><id>https://programelot.github.io/atom.xml</id><title type="html">REAL</title><subtitle>I am Programelot who is researching about optimization.</subtitle><author><name>Programelot</name></author><entry><title type="html">Stack and queue</title><link href="https://programelot.github.io/2021/08/13/Stack-Queue/" rel="alternate" type="text/html" title="Stack and queue" /><published>2021-08-13T00:00:00+09:00</published><updated>2021-08-13T00:00:00+09:00</updated><id>https://programelot.github.io/2021/08/13/Stack%20Queue</id><content type="html" xml:base="https://programelot.github.io/2021/08/13/Stack-Queue/">&lt;p&gt;There is another data strucutre that used to store tons of data.
Therefore, it has two special operations known as the insert and the pop.
However, there are two types of ways to make policies for inserting and poping a data from a structure.&lt;/p&gt;

&lt;p&gt;Depending on this two method, it is so-called as a stack or a queue.
Stack has a property known as LIFO(Last-In-First-Out).
Queue has a property known as FIFO(First-In-First-Out).&lt;/p&gt;

&lt;h2 id=&quot;stack&quot;&gt;Stack&lt;/h2&gt;
&lt;p&gt;If we insert a data into a stack first, it should be popped from the stack first.
Therefore, it reserves the order we inserted even when it is popped.&lt;/p&gt;

&lt;h2 id=&quot;queue&quot;&gt;Queue&lt;/h2&gt;
&lt;p&gt;If we insert a data into a queue first, it should be popped from the stack later.
Therefore, it reverses the order we inserted even when it is popped.&lt;/p&gt;

&lt;h2 id=&quot;complexity&quot;&gt;Complexity&lt;/h2&gt;
&lt;p&gt;If we use a list for implementing a stack and a queue, it is easy to get a good performance because we already has $O(1)$ complexity for inserting and deleting at the front and the end of the list.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Time complexity&lt;/th&gt;
      &lt;th&gt;Stack&lt;/th&gt;
      &lt;th&gt;Queue&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Insert&lt;/td&gt;
      &lt;td&gt;$O(1)$&lt;/td&gt;
      &lt;td&gt;$O(1)$&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Pop&lt;/td&gt;
      &lt;td&gt;$O(1)$&lt;/td&gt;
      &lt;td&gt;$O(1)$&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Space complexity&lt;/td&gt;
      &lt;td&gt;$O(n)$&lt;/td&gt;
      &lt;td&gt;$O(n)$&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;</content><author><name>Programelot</name></author><category term="algorithm" /><summary type="html">There is another data strucutre that used to store tons of data. Therefore, it has two special operations known as the insert and the pop. However, there are two types of ways to make policies for inserting and poping a data from a structure.</summary></entry><entry><title type="html">Array and list</title><link href="https://programelot.github.io/2021/08/12/Array-List/" rel="alternate" type="text/html" title="Array and list" /><published>2021-08-12T00:00:00+09:00</published><updated>2021-08-12T00:00:00+09:00</updated><id>https://programelot.github.io/2021/08/12/Array%20List</id><content type="html" xml:base="https://programelot.github.io/2021/08/12/Array-List/">&lt;p&gt;Before talking about algorithm itself, we need to talk about data structures that typically uses for algorithms.
Some of algorithms even works based on a specific data structure that optimizes the algorithm.
In this chapter, I’ll explain the most common data structures only.&lt;/p&gt;

&lt;h2 id=&quot;array&quot;&gt;Array&lt;/h2&gt;

&lt;p&gt;To store a number of data, there should be some data structure that can give a specific data you want anytime and store a data in to the storage either.
To acheive this property, there is the easiest data structure known as an array.
Like the name itself, it stores data in an array of storage.
Pros of this algorithm is that you can get a data anytime from an array in a constant time because all you need is an index.
In mathmatical format, it usually written as $a[0]$ or $a_0$.
However, there is a big disadvantange for this.
If you want to use an array, you need to know exact size of data you need.
Otherwise, you may can access to the data where you didn’t meant to.
Therefore, it has a big disadvantage known as the fixed-size.
However, it can extend the array by making a new array and copy every element in side of the array.
Therefore, complexity of an array is like follow.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Time complexity&lt;/th&gt;
      &lt;th&gt;Array&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Search/Change&lt;/td&gt;
      &lt;td&gt;$O(1)$&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Add (Front)&lt;/td&gt;
      &lt;td&gt;$O(n)$&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Add (Random)&lt;/td&gt;
      &lt;td&gt;$O(n)$&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Add (Back)&lt;/td&gt;
      &lt;td&gt;$O(n)$&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Delete (Front)&lt;/td&gt;
      &lt;td&gt;$O(n)$&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Delete (Random)&lt;/td&gt;
      &lt;td&gt;$O(n)$&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Delete (Back)&lt;/td&gt;
      &lt;td&gt;$O(n)$&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Merge&lt;/td&gt;
      &lt;td&gt;$O(n)$&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Space complexity&lt;/td&gt;
      &lt;td&gt;$O(n)$&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Notice that adding and delete will change the size of the array.
Merge means that merging two array into a single array.
It will be assumed to have the same size of two arrays.&lt;/p&gt;

&lt;h2 id=&quot;list-1&quot;&gt;List 1&lt;/h2&gt;

&lt;p&gt;To avoid this fixed-size problem, there is an alternative structure known as a list.
A list consists of nodes.
Each node has a data and a pointer to the next node.
Therefore, it can access to next node from any node.
However, it has a slow search algorithm because it can access only the next node.
Therefore, it takes a linear time to read an array.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Time complexity&lt;/th&gt;
      &lt;th&gt;List 1&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Search/Change&lt;/td&gt;
      &lt;td&gt;$O(n)$&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Add (Front)&lt;/td&gt;
      &lt;td&gt;$O(1)$&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Add (Random)&lt;/td&gt;
      &lt;td&gt;$O(n)$&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Add (Back)&lt;/td&gt;
      &lt;td&gt;$O(n)$&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Delete (Front)&lt;/td&gt;
      &lt;td&gt;$O(1)$&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Delete (Random)&lt;/td&gt;
      &lt;td&gt;$O(n)$&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Delete (Back)&lt;/td&gt;
      &lt;td&gt;$O(n)$&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Merge&lt;/td&gt;
      &lt;td&gt;$O(n)$&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Space complexity&lt;/td&gt;
      &lt;td&gt;$O(n)$&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;One other problem is that it can only add the new data without overhead at the front of the list.
Therefore, there is another ways to make a list.&lt;/p&gt;

&lt;h2 id=&quot;list-2&quot;&gt;List 2&lt;/h2&gt;

&lt;p&gt;What if we make a pointer to denotes the last point of the list at the same time?
It will gives an advantages that makes accessable at the end of the list.
Therefore, it will give better performance when it works for the end of the list.
At the same time, it has an advantage to merge two lists because it can connect the end point of a list to another list.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Time complexity&lt;/th&gt;
      &lt;th&gt;List 2&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Search/Change&lt;/td&gt;
      &lt;td&gt;$O(n)$&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Add (Front)&lt;/td&gt;
      &lt;td&gt;$O(1)$&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Add (Random)&lt;/td&gt;
      &lt;td&gt;$O(n)$&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Add (Back)&lt;/td&gt;
      &lt;td&gt;$O(1)$&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Delete (Front)&lt;/td&gt;
      &lt;td&gt;$O(1)$&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Delete (Random)&lt;/td&gt;
      &lt;td&gt;$O(n)$&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Delete (Back)&lt;/td&gt;
      &lt;td&gt;$O(1)$&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Merge&lt;/td&gt;
      &lt;td&gt;$O(1)$&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Space complexity&lt;/td&gt;
      &lt;td&gt;$O(n)$&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;However, it still has $O(n)$ complexity for read/change operation.
Therefore, it usually doesn’t be used in actual implementation however the notation of the list is typically used for many other data structures.&lt;/p&gt;

&lt;h2 id=&quot;vector&quot;&gt;Vector&lt;/h2&gt;

&lt;p&gt;Last implementation is which standard c++ language uses.
It works like an ordinary array but it increases its size by double the size.
It gives a nice performance because it gives a constant complexity for adding and deleting data at the back of the array.
Notice that this is amortized analysis.
Therefore, it sometimes cause long term process.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Time complexity&lt;/th&gt;
      &lt;th&gt;Vector&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Search/Change&lt;/td&gt;
      &lt;td&gt;$O(1)$&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Add (Front)&lt;/td&gt;
      &lt;td&gt;$O(n)$&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Add (Random)&lt;/td&gt;
      &lt;td&gt;$O(n)$&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Add (Back)&lt;/td&gt;
      &lt;td&gt;Amortized $O(1)$&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Delete (Front)&lt;/td&gt;
      &lt;td&gt;$O(n)$&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Delete (Random)&lt;/td&gt;
      &lt;td&gt;$O(n)$&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Delete (Back)&lt;/td&gt;
      &lt;td&gt;Amortized $O(1)$&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Merge&lt;/td&gt;
      &lt;td&gt;$O(n)$&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Space complexity&lt;/td&gt;
      &lt;td&gt;$O(n)$&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;comparison&quot;&gt;Comparison&lt;/h2&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Time complexity&lt;/th&gt;
      &lt;th&gt;Array&lt;/th&gt;
      &lt;th&gt;List 1&lt;/th&gt;
      &lt;th&gt;List 2&lt;/th&gt;
      &lt;th&gt;Vector&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Search/Change&lt;/td&gt;
      &lt;td&gt;$O(1)$&lt;/td&gt;
      &lt;td&gt;$O(n)$&lt;/td&gt;
      &lt;td&gt;$O(n)$&lt;/td&gt;
      &lt;td&gt;$O(1)$&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Add (Front)&lt;/td&gt;
      &lt;td&gt;$O(n)$&lt;/td&gt;
      &lt;td&gt;$O(1)$&lt;/td&gt;
      &lt;td&gt;$O(1)$&lt;/td&gt;
      &lt;td&gt;$O(n)$&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Add (Random)&lt;/td&gt;
      &lt;td&gt;$O(n)$&lt;/td&gt;
      &lt;td&gt;$O(n)$&lt;/td&gt;
      &lt;td&gt;$O(n)$&lt;/td&gt;
      &lt;td&gt;$O(n)$&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Add (Back)&lt;/td&gt;
      &lt;td&gt;$O(n)$&lt;/td&gt;
      &lt;td&gt;$O(n)$&lt;/td&gt;
      &lt;td&gt;$O(1)$&lt;/td&gt;
      &lt;td&gt;Amortized $O(1)$&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Delete (Front)&lt;/td&gt;
      &lt;td&gt;$O(n)$&lt;/td&gt;
      &lt;td&gt;$O(1)$&lt;/td&gt;
      &lt;td&gt;$O(1)$&lt;/td&gt;
      &lt;td&gt;$O(n)$&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Delete (Random)&lt;/td&gt;
      &lt;td&gt;$O(n)$&lt;/td&gt;
      &lt;td&gt;$O(n)$&lt;/td&gt;
      &lt;td&gt;$O(n)$&lt;/td&gt;
      &lt;td&gt;$O(n)$&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Delete (Back)&lt;/td&gt;
      &lt;td&gt;$O(n)$&lt;/td&gt;
      &lt;td&gt;$O(n)$&lt;/td&gt;
      &lt;td&gt;$O(1)$&lt;/td&gt;
      &lt;td&gt;Amortized $O(1)$&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Merge&lt;/td&gt;
      &lt;td&gt;$O(n)$&lt;/td&gt;
      &lt;td&gt;$O(n)$&lt;/td&gt;
      &lt;td&gt;$O(1)$&lt;/td&gt;
      &lt;td&gt;$O(n)$&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Space complexity&lt;/td&gt;
      &lt;td&gt;$O(n)$&lt;/td&gt;
      &lt;td&gt;$O(n)$&lt;/td&gt;
      &lt;td&gt;$O(n)$&lt;/td&gt;
      &lt;td&gt;$O(n)$&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;</content><author><name>Programelot</name></author><category term="algorithm" /><summary type="html">Before talking about algorithm itself, we need to talk about data structures that typically uses for algorithms. Some of algorithms even works based on a specific data structure that optimizes the algorithm. In this chapter, I’ll explain the most common data structures only.</summary></entry><entry><title type="html">Complexity</title><link href="https://programelot.github.io/2021/08/10/Complexity/" rel="alternate" type="text/html" title="Complexity" /><published>2021-08-10T00:00:00+09:00</published><updated>2021-08-10T00:00:00+09:00</updated><id>https://programelot.github.io/2021/08/10/Complexity</id><content type="html" xml:base="https://programelot.github.io/2021/08/10/Complexity/">&lt;p&gt;To analyze performances of algorithms, we need to define some jargons.&lt;/p&gt;

&lt;h2 id=&quot;time-complexity&quot;&gt;Time complexity&lt;/h2&gt;

&lt;p&gt;The time complexity of an algorithm, $T(n)$ is a function that denotes running time of the algorithm depending on the size of input data.
For example, let’s think about an algorithm that adds data with other data.
You may smart enough to add any arbitrary two number in 1 second.
Then, how many time will it took for 100 data?
It will be 100 seconds.
In this case, $T(n) = n$.&lt;/p&gt;

&lt;h2 id=&quot;big-o-notation&quot;&gt;Big O notation&lt;/h2&gt;

&lt;p&gt;Big O notation is the method to guarantee the upper bound of algorithms’ perforamce.
For any time complexity $T(n)$, we say $T(n)$ $=$ $O(g(n))$ if there is some positive constant $M$,$x_0$ such that $T(n)$ $\le$ $M g(n)$ for all $x \ge x_0$.
For example, if $T(n)$ $=$ $n^3$ $+$ $10n^2$ $+$ $n$ $+$ $27$, $T(n)$ $=$ $O(n^3)$ for $M$ $=$ $39$, $x_0$ $=$ $1$.
Notice that $T(n)$ $=$ $n^3$ $+$ $10n^2$ $+$ $n$ $+$ $27$ $\le$ $n^3$ $+$ $10n^3$ $+$ $n^3$ $+$ $27n^3$ $=$ $39n^3$ for $n$ $\ge$ $1$.
In fact, it is enough to find the most steepest part in $T(n)$.&lt;/p&gt;

&lt;h2 id=&quot;asymptotically-approximate&quot;&gt;Asymptotically approximate&lt;/h2&gt;

&lt;p&gt;In fact, it can be choosed to be worse than expected in big O notation.
For example, $T(n)$ $=$ $O(n^2)$ if $T(n)$ $=$ $O(n)$ in all cases.
Therefore, we say that “An algorithm’s time complexity asymptotically approximates to $g(n)$” when $\lim\limits_{n \leftarrow \infty}\frac{T(n)}{Mg(n)} = 1$ for some positive constant $M$.&lt;/p&gt;

&lt;h2 id=&quot;big-omega-notation&quot;&gt;Big $\Omega$ notation&lt;/h2&gt;

&lt;p&gt;Big $\Omega$ notation is the opposite with the big O notation.
It guarantess the lower bound of algorithms’ performance.
For any time complexity $T(n)$, we say $T(n)$ $=$ $\Omega(g(n))$ if there is some positive constant $M$,$x_0$ such that $T(n)$ $\ge$ $M g(n)$ for all $x \ge x_0$.&lt;/p&gt;

&lt;h2 id=&quot;big-theta-notation&quot;&gt;Big $\Theta$ notation&lt;/h2&gt;

&lt;p&gt;Big theta notation is used when an algorithm has the same complexity for both upper and lower bounds.
In other word, we say $T(n)$ $=$ $\Theta(g(n))$ if there is some positive constant $M1$,$M_2$,$x_0$ such that $M_2 g(n)$ $\le$ $T(n)$ $\le$ $M_1 g(n)$ for all $x \ge x_0$.
However, it is hard to expect that algorithm has such a complexity.
Some algorithms’ performance vary between the data itself.
Therefore, some algorithm can’t have big $\Theta$ notation for their time complexity.&lt;/p&gt;

&lt;h2 id=&quot;amortized-complexity&quot;&gt;Amortized complexity&lt;/h2&gt;

&lt;p&gt;Amortized complexity is another measurement to analysis an algorithm.
Many algorithms doesn’t have a nice $\Theta$ notation to explain the performance’s performance.
It really depends on the situation.
However, it can be pessimistic to use only big O notation.
Therefore, amortized complexity measures a performance of an algorithm by dividing its complexity between executions.
If some algorithm works $O(1)$ for $n$ times and it works $O(n^2)$ for $1$ time.
Then, the amortized complexity of this algorithm is $O(\frac{1 \times n + n^2}{n + 1})$ $=$ $O(n)$.&lt;/p&gt;

&lt;h2 id=&quot;space-complexity&quot;&gt;Space complexity&lt;/h2&gt;

&lt;p&gt;Space complexity is another measurable tool for algorithms.
It denotes how many memory spaces it uses.
We use all of notations above to represent space complexity either.&lt;/p&gt;</content><author><name>Programelot</name></author><category term="algorithm" /><summary type="html">To analyze performances of algorithms, we need to define some jargons.</summary></entry><entry><title type="html">Algorithm</title><link href="https://programelot.github.io/2021/08/02/Algorithm/" rel="alternate" type="text/html" title="Algorithm" /><published>2021-08-02T00:00:00+09:00</published><updated>2021-08-02T00:00:00+09:00</updated><id>https://programelot.github.io/2021/08/02/Algorithm</id><content type="html" xml:base="https://programelot.github.io/2021/08/02/Algorithm/">&lt;p&gt;Algorithm is a mathmatical tool to solve some problem with propal methods.
For example, let’s think about a situation follows.
Oneday, you’ve got a job from a city library.
However, there was a tournado yesterday so all books dropped out of the shelf.
Your employer calls you and asks you to clean it up in order of books’ ID.
Despite of your low payment, you have no way but clean it up.
Therefore, you started to think about the way to clean it up.&lt;/p&gt;

&lt;h2 id=&quot;insertion-sort&quot;&gt;Insertion sort&lt;/h2&gt;
&lt;p&gt;You may give up to think about better way to clean it up.
Instead of it, you just started to clean it up by reading the ID of each book and put the book which has the smallest ID into the shelf.&lt;/p&gt;

&lt;h2 id=&quot;quick-sort&quot;&gt;Quick sort&lt;/h2&gt;
&lt;p&gt;While you are doing such a thing, your friend decided to do the follow.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;If there is only one book, just put it in with the revered direction.&lt;/li&gt;
  &lt;li&gt;If there is more than a book, select a book in random.&lt;/li&gt;
  &lt;li&gt;Put all books that have smaller ID than the book that you selected at 1 into the shelf.&lt;/li&gt;
  &lt;li&gt;Then add the book that you selected at 1 but in the reversed direction to identify this is the book which you used.&lt;/li&gt;
  &lt;li&gt;If all books are in the self with inverse direction, flip all books.&lt;/li&gt;
  &lt;li&gt;Otherwise, pick books between two reversed book and take books out of the shelf and do the same process from 1.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Notice that the starting point, end point of the shelf will be considered as the reversed book in 6.&lt;/p&gt;

&lt;p&gt;This looks more complex but it usually takes much less time than you did.
See the example below.&lt;/p&gt;

&lt;h2 id=&quot;example&quot;&gt;Example&lt;/h2&gt;
&lt;p&gt;For example, there are books that have IDs of 52,33,25,19,28,38,37,45,73,68,61,69,87,78,90.
Now, let’s follow the each process.&lt;/p&gt;

&lt;p&gt;You will clean the book like bellow.
Notice that I marked [] as books that shelf has, {} as what you are memorizing and () as what you are looking.
In this algorithm, you can see only one book at once because numbers are too complex to see it on glance.
At the same time, you can memorize a number at most because of its long digits.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;(52), 33, 25, 19, 28, 38, 37, 45, 73, 68, 61, 69, 87, 78, 90&lt;/li&gt;
  &lt;li&gt;{52}, (33), 25, 19, 28, 38, 37, 45, 73, 68, 61, 69, 87, 78, 90&lt;/li&gt;
  &lt;li&gt;52, {33}, (25), 19, 28, 38, 37, 45, 73, 68, 61, 69, 87, 78, 90&lt;/li&gt;
  &lt;li&gt;52, 33, {25}, (19), 28, 38, 37, 45, 73, 68, 61, 69, 87, 78, 90&lt;/li&gt;
  &lt;li&gt;52, 33, 25, {19}, (28), 38, 37, 45, 73, 68, 61, 69, 87, 78, 90&lt;/li&gt;
  &lt;li&gt;52, 33, 25, {19}, 28, (38), 37, 45, 73, 68, 61, 69, 87, 78, 90&lt;/li&gt;
  &lt;li&gt;52, 33, 25, {19}, 28, 38, (37), 45, 73, 68, 61, 69, 87, 78, 90&lt;/li&gt;
  &lt;li&gt;52, 33, 25, {19}, 28, 38, 37, (45), 73, 68, 61, 69, 87, 78, 90&lt;/li&gt;
  &lt;li&gt;52, 33, 25, {19}, 28, 38, 37, 45, (73), 68, 61, 69, 87, 78, 90&lt;/li&gt;
  &lt;li&gt;52, 33, 25, {19}, 28, 38, 37, 45, 73, (68), 61, 69, 87, 78, 90&lt;/li&gt;
  &lt;li&gt;52, 33, 25, {19}, 28, 38, 37, 45, 73, 68, (61), 69, 87, 78, 90&lt;/li&gt;
  &lt;li&gt;52, 33, 25, {19}, 28, 38, 37, 45, 73, 68, 61, (69), 87, 78, 90&lt;/li&gt;
  &lt;li&gt;52, 33, 25, {19}, 28, 38, 37, 45, 73, 68, 61, 69, (87), 78, 90&lt;/li&gt;
  &lt;li&gt;52, 33, 25, {19}, 28, 38, 37, 45, 73, 68, 61, 69, 87, (78), 90&lt;/li&gt;
  &lt;li&gt;52, 33, 25, {19}, 28, 38, 37, 45, 73, 68, 61, 69, 87, 78, (90)&lt;/li&gt;
  &lt;li&gt;[19], 52, 33, 25, 28, 38, 37, 45, 73, 68, 61, 69, 87, 78, 90&lt;/li&gt;
  &lt;li&gt;[19], (52), 33, 25, 28, 38, 37, 45, 73, 68, 61, 69, 87, 78, 90&lt;/li&gt;
  &lt;li&gt;[19], {52}, (33), 25, 28, 38, 37, 45, 73, 68, 61, 69, 87, 78, 90&lt;/li&gt;
  &lt;li&gt;[19], 52, {33}, (25), 28, 38, 37, 45, 73, 68, 61, 69, 87, 78, 90&lt;/li&gt;
  &lt;li&gt;[19], 52, 33, {25}, (28), 38, 37, 45, 73, 68, 61, 69, 87, 78, 90&lt;/li&gt;
  &lt;li&gt;[19], 52, 33, {25}, 28, (38), 37, 45, 73, 68, 61, 69, 87, 78, 90&lt;/li&gt;
  &lt;li&gt;[19], 52, 33, {25}, 28, 38, (37), 45, 73, 68, 61, 69, 87, 78, 90&lt;/li&gt;
  &lt;li&gt;[19], 52, 33, {25}, 28, 38, 37, (45), 73, 68, 61, 69, 87, 78, 90&lt;/li&gt;
  &lt;li&gt;[19], 52, 33, {25}, 28, 38, 37, 45, (73), 68, 61, 69, 87, 78, 90&lt;/li&gt;
  &lt;li&gt;[19], 52, 33, {25}, 28, 38, 37, 45, 73, (68), 61, 69, 87, 78, 90&lt;/li&gt;
  &lt;li&gt;[19], 52, 33, {25}, 28, 38, 37, 45, 73, 68, (61), 69, 87, 78, 90&lt;/li&gt;
  &lt;li&gt;[19], 52, 33, {25}, 28, 38, 37, 45, 73, 68, 61, (69), 87, 78, 90&lt;/li&gt;
  &lt;li&gt;[19], 52, 33, {25}, 28, 38, 37, 45, 73, 68, 61, 69, (87), 78, 90&lt;/li&gt;
  &lt;li&gt;[19], 52, 33, {25}, 28, 38, 37, 45, 73, 68, 61, 69, 87, (78), 90&lt;/li&gt;
  &lt;li&gt;[19], 52, 33, {25}, 28, 38, 37, 45, 73, 68, 61, 69, 87, 78, (90)&lt;/li&gt;
  &lt;li&gt;[19, 25], 52, 33, 28, 38, 37, 45, 73, 68, 61, 69, 87, 78, 90&lt;/li&gt;
  &lt;li&gt;[19, 25], (52), 33, 28, 38, 37, 45, 73, 68, 61, 69, 87, 78, 90&lt;/li&gt;
  &lt;li&gt;[19, 25], {52}, (33), 28, 38, 37, 45, 73, 68, 61, 69, 87, 78, 90&lt;/li&gt;
  &lt;li&gt;[19, 25], 52, {33}, (28), 38, 37, 45, 73, 68, 61, 69, 87, 78, 90&lt;/li&gt;
  &lt;li&gt;[19, 25], 52, 33, {28}, (38), 37, 45, 73, 68, 61, 69, 87, 78, 90&lt;/li&gt;
  &lt;li&gt;[19, 25], 52, 33, {28}, 38, (37), 45, 73, 68, 61, 69, 87, 78, 90&lt;/li&gt;
  &lt;li&gt;[19, 25], 52, 33, {28}, 38, 37, (45), 73, 68, 61, 69, 87, 78, 90&lt;/li&gt;
  &lt;li&gt;[19, 25], 52, 33, {28}, 38, 37, 45, (73), 68, 61, 69, 87, 78, 90&lt;/li&gt;
  &lt;li&gt;[19, 25], 52, 33, {28}, 38, 37, 45, 73, (68), 61, 69, 87, 78, 90&lt;/li&gt;
  &lt;li&gt;[19, 25], 52, 33, {28}, 38, 37, 45, 73, 68, (61), 69, 87, 78, 90&lt;/li&gt;
  &lt;li&gt;[19, 25], 52, 33, {28}, 38, 37, 45, 73, 68, 61, (69), 87, 78, 90&lt;/li&gt;
  &lt;li&gt;[19, 25], 52, 33, {28}, 38, 37, 45, 73, 68, 61, 69, (87), 78, 90&lt;/li&gt;
  &lt;li&gt;[19, 25], 52, 33, {28}, 38, 37, 45, 73, 68, 61, 69, 87, (78), 90&lt;/li&gt;
  &lt;li&gt;[19, 25], 52, 33, {28}, 38, 37, 45, 73, 68, 61, 69, 87, 78, (90)&lt;/li&gt;
  &lt;li&gt;[19, 25, 28], 52, 33, 38, 37, 45, 73, 68, 61, 69, 87, 78, 90&lt;/li&gt;
  &lt;li&gt;[19, 25, 28], (52), 33, 38, 37, 45, 73, 68, 61, 69, 87, 78, 90&lt;/li&gt;
  &lt;li&gt;[19, 25, 28], {52}, (33), 38, 37, 45, 73, 68, 61, 69, 87, 78, 90&lt;/li&gt;
  &lt;li&gt;[19, 25, 28], 52, {33}, (38), 37, 45, 73, 68, 61, 69, 87, 78, 90&lt;/li&gt;
  &lt;li&gt;[19, 25, 28], 52, {33}, 38, (37), 45, 73, 68, 61, 69, 87, 78, 90&lt;/li&gt;
  &lt;li&gt;[19, 25, 28], 52, {33}, 38, 37, (45), 73, 68, 61, 69, 87, 78, 90&lt;/li&gt;
  &lt;li&gt;[19, 25, 28], 52, {33}, 38, 37, 45, (73), 68, 61, 69, 87, 78, 90&lt;/li&gt;
  &lt;li&gt;[19, 25, 28], 52, {33}, 38, 37, 45, 73, (68), 61, 69, 87, 78, 90&lt;/li&gt;
  &lt;li&gt;[19, 25, 28], 52, {33}, 38, 37, 45, 73, 68, (61), 69, 87, 78, 90&lt;/li&gt;
  &lt;li&gt;[19, 25, 28], 52, {33}, 38, 37, 45, 73, 68, 61, (69), 87, 78, 90&lt;/li&gt;
  &lt;li&gt;[19, 25, 28], 52, {33}, 38, 37, 45, 73, 68, 61, 69, (87), 78, 90&lt;/li&gt;
  &lt;li&gt;[19, 25, 28], 52, {33}, 38, 37, 45, 73, 68, 61, 69, 87, (78), 90&lt;/li&gt;
  &lt;li&gt;[19, 25, 28], 52, {33}, 38, 37, 45, 73, 68, 61, 69, 87, 78, (90)&lt;/li&gt;
  &lt;li&gt;[19, 25, 28, 33], 52, 38, 37, 45, 73, 68, 61, 69, 87, 78, 90&lt;/li&gt;
  &lt;li&gt;[19, 25, 28, 33], (52), 38, 37, 45, 73, 68, 61, 69, 87, 78, 90&lt;/li&gt;
  &lt;li&gt;[19, 25, 28, 33], {52}, (38), 37, 45, 73, 68, 61, 69, 87, 78, 90&lt;/li&gt;
  &lt;li&gt;[19, 25, 28, 33], 52, {38}, (37), 45, 73, 68, 61, 69, 87, 78, 90&lt;/li&gt;
  &lt;li&gt;[19, 25, 28, 33], 52, 38, {37}, (45), 73, 68, 61, 69, 87, 78, 90&lt;/li&gt;
  &lt;li&gt;[19, 25, 28, 33], 52, 38, {37}, 45, (73), 68, 61, 69, 87, 78, 90&lt;/li&gt;
  &lt;li&gt;[19, 25, 28, 33], 52, 38, {37}, 45, 73, (68), 61, 69, 87, 78, 90&lt;/li&gt;
  &lt;li&gt;[19, 25, 28, 33], 52, 38, {37}, 45, 73, 68, (61), 69, 87, 78, 90&lt;/li&gt;
  &lt;li&gt;[19, 25, 28, 33], 52, 38, {37}, 45, 73, 68, 61, (69), 87, 78, 90&lt;/li&gt;
  &lt;li&gt;[19, 25, 28, 33], 52, 38, {37}, 45, 73, 68, 61, 69, (87), 78, 90&lt;/li&gt;
  &lt;li&gt;[19, 25, 28, 33], 52, 38, {37}, 45, 73, 68, 61, 69, 87, (78), 90&lt;/li&gt;
  &lt;li&gt;[19, 25, 28, 33], 52, 38, {37}, 45, 73, 68, 61, 69, 87, 78, (90)&lt;/li&gt;
  &lt;li&gt;[19, 25, 28, 33, 37], 52, 38, 45, 73, 68, 61, 69, 87, 78, 90&lt;/li&gt;
  &lt;li&gt;[19, 25, 28, 33, 37], (52), 38, 45, 73, 68, 61, 69, 87, 78, 90&lt;/li&gt;
  &lt;li&gt;[19, 25, 28, 33, 37], {52}, (38), 45, 73, 68, 61, 69, 87, 78, 90&lt;/li&gt;
  &lt;li&gt;[19, 25, 28, 33, 37], 52, {38}, (45), 73, 68, 61, 69, 87, 78, 90&lt;/li&gt;
  &lt;li&gt;[19, 25, 28, 33, 37], 52, {38}, 45, (73), 68, 61, 69, 87, 78, 90&lt;/li&gt;
  &lt;li&gt;[19, 25, 28, 33, 37], 52, {38}, 45, 73, (68), 61, 69, 87, 78, 90&lt;/li&gt;
  &lt;li&gt;[19, 25, 28, 33, 37], 52, {38}, 45, 73, 68, (61), 69, 87, 78, 90&lt;/li&gt;
  &lt;li&gt;[19, 25, 28, 33, 37], 52, {38}, 45, 73, 68, 61, (69), 87, 78, 90&lt;/li&gt;
  &lt;li&gt;[19, 25, 28, 33, 37], 52, {38}, 45, 73, 68, 61, 69, (87), 78, 90&lt;/li&gt;
  &lt;li&gt;[19, 25, 28, 33, 37], 52, {38}, 45, 73, 68, 61, 69, 87, (78), 90&lt;/li&gt;
  &lt;li&gt;[19, 25, 28, 33, 37], 52, {38}, 45, 73, 68, 61, 69, 87, 78, (90)&lt;/li&gt;
  &lt;li&gt;[19, 25, 28, 33, 37, 38], 52, 45, 73, 68, 61, 69, 87, 78, 90&lt;/li&gt;
  &lt;li&gt;[19, 25, 28, 33, 37, 38], (52), 45, 73, 68, 61, 69, 87, 78, 90&lt;/li&gt;
  &lt;li&gt;[19, 25, 28, 33, 37, 38], {52}, (45), 73, 68, 61, 69, 87, 78, 90&lt;/li&gt;
  &lt;li&gt;[19, 25, 28, 33, 37, 38], 52, {45}, (73), 68, 61, 69, 87, 78, 90&lt;/li&gt;
  &lt;li&gt;[19, 25, 28, 33, 37, 38], 52, {45}, 73, (68), 61, 69, 87, 78, 90&lt;/li&gt;
  &lt;li&gt;[19, 25, 28, 33, 37, 38], 52, {45}, 73, 68, (61), 69, 87, 78, 90&lt;/li&gt;
  &lt;li&gt;[19, 25, 28, 33, 37, 38], 52, {45}, 73, 68, 61, (69), 87, 78, 90&lt;/li&gt;
  &lt;li&gt;[19, 25, 28, 33, 37, 38], 52, {45}, 73, 68, 61, 69, (87), 78, 90&lt;/li&gt;
  &lt;li&gt;[19, 25, 28, 33, 37, 38], 52, {45}, 73, 68, 61, 69, 87, (78), 90&lt;/li&gt;
  &lt;li&gt;[19, 25, 28, 33, 37, 38], 52, {45}, 73, 68, 61, 69, 87, 78, (90)&lt;/li&gt;
  &lt;li&gt;[19, 25, 28, 33, 37, 38, 45], 52, 73, 68, 61, 69, 87, 78, 90&lt;/li&gt;
  &lt;li&gt;[19, 25, 28, 33, 37, 38, 45], (52), 73, 68, 61, 69, 87, 78, 90&lt;/li&gt;
  &lt;li&gt;[19, 25, 28, 33, 37, 38, 45], {52}, (73), 68, 61, 69, 87, 78, 90&lt;/li&gt;
  &lt;li&gt;[19, 25, 28, 33, 37, 38, 45], {52}, 73, (68), 61, 69, 87, 78, 90&lt;/li&gt;
  &lt;li&gt;[19, 25, 28, 33, 37, 38, 45], {52}, 73, 68, (61), 69, 87, 78, 90&lt;/li&gt;
  &lt;li&gt;[19, 25, 28, 33, 37, 38, 45], {52}, 73, 68, 61, (69), 87, 78, 90&lt;/li&gt;
  &lt;li&gt;[19, 25, 28, 33, 37, 38, 45], {52}, 73, 68, 61, 69, (87), 78, 90&lt;/li&gt;
  &lt;li&gt;[19, 25, 28, 33, 37, 38, 45], {52}, 73, 68, 61, 69, 87, (78), 90&lt;/li&gt;
  &lt;li&gt;[19, 25, 28, 33, 37, 38, 45], {52}, 73, 68, 61, 69, 87, 78, (90)&lt;/li&gt;
  &lt;li&gt;[19, 25, 28, 33, 37, 38, 45, 52], 73, 68, 61, 69, 87, 78, 90&lt;/li&gt;
  &lt;li&gt;[19, 25, 28, 33, 37, 38, 45, 52], (73), 68, 61, 69, 87, 78, 90&lt;/li&gt;
  &lt;li&gt;[19, 25, 28, 33, 37, 38, 45, 52], {73}, (68), 61, 69, 87, 78, 90&lt;/li&gt;
  &lt;li&gt;[19, 25, 28, 33, 37, 38, 45, 52], 73, {68}, (61), 69, 87, 78, 90&lt;/li&gt;
  &lt;li&gt;[19, 25, 28, 33, 37, 38, 45, 52], 73, 68, {61}, (69), 87, 78, 90&lt;/li&gt;
  &lt;li&gt;[19, 25, 28, 33, 37, 38, 45, 52], 73, 68, {61}, 69, (87), 78, 90&lt;/li&gt;
  &lt;li&gt;[19, 25, 28, 33, 37, 38, 45, 52], 73, 68, {61}, 69, 87, (78), 90&lt;/li&gt;
  &lt;li&gt;[19, 25, 28, 33, 37, 38, 45, 52], 73, 68, {61}, 69, 87, 78, (90)&lt;/li&gt;
  &lt;li&gt;[19, 25, 28, 33, 37, 38, 45, 52, 61], 73, 68, 69, 87, 78, 90&lt;/li&gt;
  &lt;li&gt;[19, 25, 28, 33, 37, 38, 45, 52, 61], (73), 68, 69, 87, 78, 90&lt;/li&gt;
  &lt;li&gt;[19, 25, 28, 33, 37, 38, 45, 52, 61], {73}, (68), 69, 87, 78, 90&lt;/li&gt;
  &lt;li&gt;[19, 25, 28, 33, 37, 38, 45, 52, 61], 73, {68}, (69), 87, 78, 90&lt;/li&gt;
  &lt;li&gt;[19, 25, 28, 33, 37, 38, 45, 52, 61], 73, {68}, 69, (87), 78, 90&lt;/li&gt;
  &lt;li&gt;[19, 25, 28, 33, 37, 38, 45, 52, 61], 73, {68}, 69, 87, (78), 90&lt;/li&gt;
  &lt;li&gt;[19, 25, 28, 33, 37, 38, 45, 52, 61], 73, {68}, 69, 87, 78, (90)&lt;/li&gt;
  &lt;li&gt;[19, 25, 28, 33, 37, 38, 45, 52, 61, 68], 73, 69, 87, 78, 90&lt;/li&gt;
  &lt;li&gt;[19, 25, 28, 33, 37, 38, 45, 52, 61, 68], (73), 69, 87, 78, 90&lt;/li&gt;
  &lt;li&gt;[19, 25, 28, 33, 37, 38, 45, 52, 61, 68], {73}, (69), 87, 78, 90&lt;/li&gt;
  &lt;li&gt;[19, 25, 28, 33, 37, 38, 45, 52, 61, 68], 73, {69}, (87), 78, 90&lt;/li&gt;
  &lt;li&gt;[19, 25, 28, 33, 37, 38, 45, 52, 61, 68], 73, {69}, 87, (78), 90&lt;/li&gt;
  &lt;li&gt;[19, 25, 28, 33, 37, 38, 45, 52, 61, 68], 73, {69}, 87, 78, (90)&lt;/li&gt;
  &lt;li&gt;[19, 25, 28, 33, 37, 38, 45, 52, 61, 68, 69], 73, 87, 78, 90&lt;/li&gt;
  &lt;li&gt;[19, 25, 28, 33, 37, 38, 45, 52, 61, 68, 69], (73), 87, 78, 90&lt;/li&gt;
  &lt;li&gt;[19, 25, 28, 33, 37, 38, 45, 52, 61, 68, 69], {73}, (87), 78, 90&lt;/li&gt;
  &lt;li&gt;[19, 25, 28, 33, 37, 38, 45, 52, 61, 68, 69], {73}, 87, (78), 90&lt;/li&gt;
  &lt;li&gt;[19, 25, 28, 33, 37, 38, 45, 52, 61, 68, 69], {73}, 87, 78, (90)&lt;/li&gt;
  &lt;li&gt;[19, 25, 28, 33, 37, 38, 45, 52, 61, 68, 69, 73], 87, 78, 90&lt;/li&gt;
  &lt;li&gt;[19, 25, 28, 33, 37, 38, 45, 52, 61, 68, 69, 73], (87), 78, 90&lt;/li&gt;
  &lt;li&gt;[19, 25, 28, 33, 37, 38, 45, 52, 61, 68, 69, 73], {87}, (78), 90&lt;/li&gt;
  &lt;li&gt;[19, 25, 28, 33, 37, 38, 45, 52, 61, 68, 69, 73], 87, {78}, (90)&lt;/li&gt;
  &lt;li&gt;[19, 25, 28, 33, 37, 38, 45, 52, 61, 68, 69, 73, 78], 87, 90&lt;/li&gt;
  &lt;li&gt;[19, 25, 28, 33, 37, 38, 45, 52, 61, 68, 69, 73, 78], (87), 90&lt;/li&gt;
  &lt;li&gt;[19, 25, 28, 33, 37, 38, 45, 52, 61, 68, 69, 73, 78], {87}, (90)&lt;/li&gt;
  &lt;li&gt;[19, 25, 28, 33, 37, 38, 45, 52, 61, 68, 69, 73, 78, 87], 90&lt;/li&gt;
  &lt;li&gt;[19, 25, 28, 33, 37, 38, 45, 52, 61, 68, 69, 73, 78, 87], (90)&lt;/li&gt;
  &lt;li&gt;[19, 25, 28, 33, 37, 38, 45, 52, 61, 68, 69, 73, 78, 87, 90]&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;As a result, it takes 135 steps.
However, your friend can get a result like below.
Notice that I marked revered book by !.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;(52), 33, 25, 19, 28, 38, 37, 45, 73, 68, 61, 69, 87, 78, 90&lt;/li&gt;
  &lt;li&gt;{52}, (33), 25, 19, 28, 38, 37, 45, 73, 68, 61, 69, 87, 78, 90&lt;/li&gt;
  &lt;li&gt;[33], {52}, 25, 19, 28, 38, 37, 45, 73, 68, 61, 69, 87, 78, 90&lt;/li&gt;
  &lt;li&gt;[33], {52}, (25), 19, 28, 38, 37, 45, 73, 68, 61, 69, 87, 78, 90&lt;/li&gt;
  &lt;li&gt;[33, 25], {52}, 19, 28, 38, 37, 45, 73, 68, 61, 69, 87, 78, 90&lt;/li&gt;
  &lt;li&gt;[33, 25], {52}, (19), 28, 38, 37, 45, 73, 68, 61, 69, 87, 78, 90&lt;/li&gt;
  &lt;li&gt;[33, 25, 19], {52}, 28, 38, 37, 45, 73, 68, 61, 69, 87, 78, 90&lt;/li&gt;
  &lt;li&gt;[33, 25, 19], {52}, (28), 38, 37, 45, 73, 68, 61, 69, 87, 78, 90&lt;/li&gt;
  &lt;li&gt;[33, 25, 19, 28], {52}, 38, 37, 45, 73, 68, 61, 69, 87, 78, 90&lt;/li&gt;
  &lt;li&gt;[33, 25, 19, 28], {52}, (38), 37, 45, 73, 68, 61, 69, 87, 78, 90&lt;/li&gt;
  &lt;li&gt;[33, 25, 19, 28, 38], {52}, 37, 45, 73, 68, 61, 69, 87, 78, 90&lt;/li&gt;
  &lt;li&gt;[33, 25, 19, 28, 38], {52}, (37), 45, 73, 68, 61, 69, 87, 78, 90&lt;/li&gt;
  &lt;li&gt;[33, 25, 19, 28, 38, 37], {52}, 45, 73, 68, 61, 69, 87, 78, 90&lt;/li&gt;
  &lt;li&gt;[33, 25, 19, 28, 38, 37], {52}, (45), 73, 68, 61, 69, 87, 78, 90&lt;/li&gt;
  &lt;li&gt;[33, 25, 19, 28, 38, 37, 45], {52}, 73, 68, 61, 69, 87, 78, 90&lt;/li&gt;
  &lt;li&gt;[33, 25, 19, 28, 38, 37, 45], {52}, (73), 68, 61, 69, 87, 78, 90&lt;/li&gt;
  &lt;li&gt;[33, 25, 19, 28, 38, 37, 45], {52}, 73, (68), 61, 69, 87, 78, 90&lt;/li&gt;
  &lt;li&gt;[33, 25, 19, 28, 38, 37, 45], {52}, 73, 68, (61), 69, 87, 78, 90&lt;/li&gt;
  &lt;li&gt;[33, 25, 19, 28, 38, 37, 45], {52}, 73, 68, 61, (69), 87, 78, 90&lt;/li&gt;
  &lt;li&gt;[33, 25, 19, 28, 38, 37, 45], {52}, 73, 68, 61, 69, (87), 78, 90&lt;/li&gt;
  &lt;li&gt;[33, 25, 19, 28, 38, 37, 45], {52}, 73, 68, 61, 69, 87, (78), 90&lt;/li&gt;
  &lt;li&gt;[33, 25, 19, 28, 38, 37, 45], {52}, 73, 68, 61, 69, 87, 78, (90)&lt;/li&gt;
  &lt;li&gt;[33, 25, 19, 28, 38, 37, 45, !52!], 73, 68, 61, 69, 87, 78, 90&lt;/li&gt;
  &lt;li&gt;[33, 25, 19, 28, 38, 37, 45, !52!], (73), 68, 61, 69, 87, 78, 90&lt;/li&gt;
  &lt;li&gt;[33, 25, 19, 28, 38, 37, 45, !52!], {73}, (68), 61, 69, 87, 78, 90&lt;/li&gt;
  &lt;li&gt;[33, 25, 19, 28, 38, 37, 45, !52!, 68], {73}, 61, 69, 87, 78, 90&lt;/li&gt;
  &lt;li&gt;[33, 25, 19, 28, 38, 37, 45, !52!, 68], {73}, (61), 69, 87, 78, 90&lt;/li&gt;
  &lt;li&gt;[33, 25, 19, 28, 38, 37, 45, !52!, 68, 61], {73}, 69, 87, 78, 90&lt;/li&gt;
  &lt;li&gt;[33, 25, 19, 28, 38, 37, 45, !52!, 68, 61], {73}, (69), 87, 78, 90&lt;/li&gt;
  &lt;li&gt;[33, 25, 19, 28, 38, 37, 45, !52!, 68, 61, 69], {73}, 87, 78, 90&lt;/li&gt;
  &lt;li&gt;[33, 25, 19, 28, 38, 37, 45, !52!, 68, 61, 69], {73}, (87), 78, 90&lt;/li&gt;
  &lt;li&gt;[33, 25, 19, 28, 38, 37, 45, !52!, 68, 61, 69], {73}, 87, (78), 90&lt;/li&gt;
  &lt;li&gt;[33, 25, 19, 28, 38, 37, 45, !52!, 68, 61, 69], {73}, 87, 78, (90)&lt;/li&gt;
  &lt;li&gt;[33, 25, 19, 28, 38, 37, 45, !52!, 68, 61, 69, !73!], 87, 78, 90&lt;/li&gt;
  &lt;li&gt;[33, 25, 19, 28, 38, 37, 45, !52!, 68, 61, 69, !73!], (87), 78, 90&lt;/li&gt;
  &lt;li&gt;[33, 25, 19, 28, 38, 37, 45, !52!, 68, 61, 69, !73!], {87}, (78), 90&lt;/li&gt;
  &lt;li&gt;[33, 25, 19, 28, 38, 37, 45, !52!, 68, 61, 69, !73!, 78], {87}, 90&lt;/li&gt;
  &lt;li&gt;[33, 25, 19, 28, 38, 37, 45, !52!, 68, 61, 69, !73!, 78], {87}, (90)&lt;/li&gt;
  &lt;li&gt;[33, 25, 19, 28, 38, 37, 45, !52!, 68, 61, 69, !73!, 78, !87!], 90&lt;/li&gt;
  &lt;li&gt;[33, 25, 19, 28, 38, 37, 45, !52!, 68, 61, 69, !73!, 78, !87!], (90)&lt;/li&gt;
  &lt;li&gt;[33, 25, 19, 28, 38, 37, 45, !52!, 68, 61, 69, !73!, 78, !87!, !90!]&lt;/li&gt;
  &lt;li&gt;[33, 25, 19, 28, 38, 37, 45, !52!, 68, 61], 69, [!73!, 78, !87!, !90!]&lt;/li&gt;
  &lt;li&gt;[33, 25, 19, 28, 38, 37, 45, !52!, 68], 61, 69, [!73!, 78, !87!, !90!]&lt;/li&gt;
  &lt;li&gt;[33, 25, 19, 28, 38, 37, 45, !52!], 68, 61, 69, [!73!, 78, !87!, !90!]&lt;/li&gt;
  &lt;li&gt;[33, 25, 19, 28, 38, 37, 45, !52!], (68), 61, 69, [!73!, 78, !87!, !90!]&lt;/li&gt;
  &lt;li&gt;[33, 25, 19, 28, 38, 37, 45, !52!], {68}, (61), 69, [!73!, 78, !87!, !90!]&lt;/li&gt;
  &lt;li&gt;[33, 25, 19, 28, 38, 37, 45, !52!, 61], {68}, 69, [!73!, 78, !87!, !90!]&lt;/li&gt;
  &lt;li&gt;[33, 25, 19, 28, 38, 37, 45, !52!, 61], {68}, (69), [!73!, 78, !87!, !90!]&lt;/li&gt;
  &lt;li&gt;[33, 25, 19, 28, 38, 37, 45, !52!, 61, !68!], 69, [!73!, 78, !87!, !90!]&lt;/li&gt;
  &lt;li&gt;[33, 25, 19, 28, 38, 37, 45, !52!, 61, !68!], (69), [!73!, 78, !87!, !90!]&lt;/li&gt;
  &lt;li&gt;[33, 25, 19, 28, 38, 37, 45, !52!, 61, !68!, !69!, !73!, 78, !87!, !90!]&lt;/li&gt;
  &lt;li&gt;[33, 25, 19, 28, 38, 37, 45, !52!], 61, [!68!, !69!, !73!, 78, !87!, !90!]&lt;/li&gt;
  &lt;li&gt;[33, 25, 19, 28, 38, 37, 45, !52!], (61), [!68!, !69!, !73!, 78, !87!, !90!]&lt;/li&gt;
  &lt;li&gt;[33, 25, 19, 28, 38, 37, 45, !52!, !61!, !68!, !69!, !73!, 78, !87!, !90!]&lt;/li&gt;
  &lt;li&gt;33, [25, 19, 28, 38, 37, 45, !52!, !61!, !68!, !69!, !73!, 78, !87!, !90!]&lt;/li&gt;
  &lt;li&gt;33, 25, [19, 28, 38, 37, 45, !52!, !61!, !68!, !69!, !73!, 78, !87!, !90!]&lt;/li&gt;
  &lt;li&gt;33, 25, 19, [28, 38, 37, 45, !52!, !61!, !68!, !69!, !73!, 78, !87!, !90!]&lt;/li&gt;
  &lt;li&gt;33, 25, 19, 28, [38, 37, 45, !52!, !61!, !68!, !69!, !73!, 78, !87!, !90!]&lt;/li&gt;
  &lt;li&gt;33, 25, 19, 28, 38, [37, 45, !52!, !61!, !68!, !69!, !73!, 78, !87!, !90!]&lt;/li&gt;
  &lt;li&gt;33, 25, 19, 28, 38, 37, [45, !52!, !61!, !68!, !69!, !73!, 78, !87!, !90!]&lt;/li&gt;
  &lt;li&gt;33, 25, 19, 28, 38, 37, 45, [!52!, !61!, !68!, !69!, !73!, 78, !87!, !90!]&lt;/li&gt;
  &lt;li&gt;(33), 25, 19, 28, 38, 37, 45, [!52!, !61!, !68!, !69!, !73!, 78, !87!, !90!]&lt;/li&gt;
  &lt;li&gt;{33}, (25), 19, 28, 38, 37, 45, [!52!, !61!, !68!, !69!, !73!, 78, !87!, !90!]&lt;/li&gt;
  &lt;li&gt;[25], {33}, 19, 28, 38, 37, 45, [!52!, !61!, !68!, !69!, !73!, 78, !87!, !90!]&lt;/li&gt;
  &lt;li&gt;[25], {33}, (19), 28, 38, 37, 45, [!52!, !61!, !68!, !69!, !73!, 78, !87!, !90!]&lt;/li&gt;
  &lt;li&gt;[25, 19], {33}, 28, 38, 37, 45, [!52!, !61!, !68!, !69!, !73!, 78, !87!, !90!]&lt;/li&gt;
  &lt;li&gt;[25, 19], {33}, (28), 38, 37, 45, [!52!, !61!, !68!, !69!, !73!, 78, !87!, !90!]&lt;/li&gt;
  &lt;li&gt;[25, 19, 28], {33}, 38, 37, 45, [!52!, !61!, !68!, !69!, !73!, 78, !87!, !90!]&lt;/li&gt;
  &lt;li&gt;[25, 19, 28], {33}, (38), 37, 45, [!52!, !61!, !68!, !69!, !73!, 78, !87!, !90!]&lt;/li&gt;
  &lt;li&gt;[25, 19, 28], {33}, 38, (37), 45, [!52!, !61!, !68!, !69!, !73!, 78, !87!, !90!]&lt;/li&gt;
  &lt;li&gt;[25, 19, 28], {33}, 38, 37, (45), [!52!, !61!, !68!, !69!, !73!, 78, !87!, !90!]&lt;/li&gt;
  &lt;li&gt;[25, 19, 28, !33!], 38, 37, 45, [!52!, !61!, !68!, !69!, !73!, 78, !87!, !90!]&lt;/li&gt;
  &lt;li&gt;[25, 19, 28, !33!], (38), 37, 45, [!52!, !61!, !68!, !69!, !73!, 78, !87!, !90!]&lt;/li&gt;
  &lt;li&gt;[25, 19, 28, !33!], {38}, (37), 45, [!52!, !61!, !68!, !69!, !73!, 78, !87!, !90!]&lt;/li&gt;
  &lt;li&gt;[25, 19, 28, !33!, 37], {38}, 45, [!52!, !61!, !68!, !69!, !73!, 78, !87!, !90!]&lt;/li&gt;
  &lt;li&gt;[25, 19, 28, !33!, 37], {38}, (45), [!52!, !61!, !68!, !69!, !73!, 78, !87!, !90!]&lt;/li&gt;
  &lt;li&gt;[25, 19, 28, !33!, 37, !38!], 45, [!52!, !61!, !68!, !69!, !73!, 78, !87!, !90!]&lt;/li&gt;
  &lt;li&gt;[25, 19, 28, !33!, 37, !38!], (45), [!52!, !61!, !68!, !69!, !73!, 78, !87!, !90!]&lt;/li&gt;
  &lt;li&gt;[25, 19, 28, !33!, 37, !38!, !45!, !52!, !61!, !68!, !69!, !73!, 78, !87!, !90!]&lt;/li&gt;
  &lt;li&gt;25, [19, 28, !33!, 37, !38!, !45!, !52!, !61!, !68!, !69!, !73!, 78, !87!, !90!]&lt;/li&gt;
  &lt;li&gt;25, 19, [28, !33!, 37, !38!, !45!, !52!, !61!, !68!, !69!, !73!, 78, !87!, !90!]&lt;/li&gt;
  &lt;li&gt;25, 19, 28, [!33!, 37, !38!, !45!, !52!, !61!, !68!, !69!, !73!, 78, !87!, !90!]&lt;/li&gt;
  &lt;li&gt;(25), 19, 28, [!33!, 37, !38!, !45!, !52!, !61!, !68!, !69!, !73!, 78, !87!, !90!]&lt;/li&gt;
  &lt;li&gt;{25}, (19), 28, [!33!, 37, !38!, !45!, !52!, !61!, !68!, !69!, !73!, 78, !87!, !90!]&lt;/li&gt;
  &lt;li&gt;[19], {25}, 28, [!33!, 37, !38!, !45!, !52!, !61!, !68!, !69!, !73!, 78, !87!, !90!]&lt;/li&gt;
  &lt;li&gt;[19], {25}, (28), [!33!, 37, !38!, !45!, !52!, !61!, !68!, !69!, !73!, 78, !87!, !90!]&lt;/li&gt;
  &lt;li&gt;[19, !25!], 28, [!33!, 37, !38!, !45!, !52!, !61!, !68!, !69!, !73!, 78, !87!, !90!]&lt;/li&gt;
  &lt;li&gt;[19, !25!], (28), [!33!, 37, !38!, !45!, !52!, !61!, !68!, !69!, !73!, 78, !87!, !90!]&lt;/li&gt;
  &lt;li&gt;[19, !25!, !28!, !33!, 37, !38!, !45!, !52!, !61!, !68!, !69!, !73!, 78, !87!, !90!]&lt;/li&gt;
  &lt;li&gt;19, [!25!, !28!, !33!, 37, !38!, !45!, !52!, !61!, !68!, !69!, !73!, 78, !87!, !90!]&lt;/li&gt;
  &lt;li&gt;(19), [!25!, !28!, !33!, 37, !38!, !45!, !52!, !61!, !68!, !69!, !73!, 78, !87!, !90!]&lt;/li&gt;
  &lt;li&gt;[!19!, !25!, !28!, !33!, 37, !38!, !45!, !52!, !61!, !68!, !69!, !73!, 78, !87!, !90!]&lt;/li&gt;
  &lt;li&gt;[!19!, !25!, !28!, !33!], 37, [!38!, !45!, !52!, !61!, !68!, !69!, !73!, 78, !87!, !90!]&lt;/li&gt;
  &lt;li&gt;[!19!, !25!, !28!, !33!], (37), [!38!, !45!, !52!, !61!, !68!, !69!, !73!, 78, !87!, !90!]&lt;/li&gt;
  &lt;li&gt;[!19!, !25!, !28!, !33!, !37!, !38!, !45!, !52!, !61!, !68!, !69!, !73!, 78, !87!, !90!]&lt;/li&gt;
  &lt;li&gt;[!19!, !25!, !28!, !33!, !37!, !38!, !45!, !52!, !61!, !68!, !69!, !73!], 78, [!87!, !90!]&lt;/li&gt;
  &lt;li&gt;[!19!, !25!, !28!, !33!, !37!, !38!, !45!, !52!, !61!, !68!, !69!, !73!], (78), [!87!, !90!]&lt;/li&gt;
  &lt;li&gt;[!19!, !25!, !28!, !33!, !37!, !38!, !45!, !52!, !61!, !68!, !69!, !73!, !78!, !87!, !90!]&lt;/li&gt;
  &lt;li&gt;[19, !25!, !28!, !33!, !37!, !38!, !45!, !52!, !61!, !68!, !69!, !73!, !78!, !87!, !90!]&lt;/li&gt;
  &lt;li&gt;[19, 25, !28!, !33!, !37!, !38!, !45!, !52!, !61!, !68!, !69!, !73!, !78!, !87!, !90!]&lt;/li&gt;
  &lt;li&gt;[19, 25, 28, !33!, !37!, !38!, !45!, !52!, !61!, !68!, !69!, !73!, !78!, !87!, !90!]&lt;/li&gt;
  &lt;li&gt;[19, 25, 28, 33, !37!, !38!, !45!, !52!, !61!, !68!, !69!, !73!, !78!, !87!, !90!]&lt;/li&gt;
  &lt;li&gt;[19, 25, 28, 33, 37, !38!, !45!, !52!, !61!, !68!, !69!, !73!, !78!, !87!, !90!]&lt;/li&gt;
  &lt;li&gt;[19, 25, 28, 33, 37, 38, !45!, !52!, !61!, !68!, !69!, !73!, !78!, !87!, !90!]&lt;/li&gt;
  &lt;li&gt;[19, 25, 28, 33, 37, 38, 45, !52!, !61!, !68!, !69!, !73!, !78!, !87!, !90!]&lt;/li&gt;
  &lt;li&gt;[19, 25, 28, 33, 37, 38, 45, 52, !61!, !68!, !69!, !73!, !78!, !87!, !90!]&lt;/li&gt;
  &lt;li&gt;[19, 25, 28, 33, 37, 38, 45, 52, 61, !68!, !69!, !73!, !78!, !87!, !90!]&lt;/li&gt;
  &lt;li&gt;[19, 25, 28, 33, 37, 38, 45, 52, 61, 68, !69!, !73!, !78!, !87!, !90!]&lt;/li&gt;
  &lt;li&gt;[19, 25, 28, 33, 37, 38, 45, 52, 61, 68, 69, !73!, !78!, !87!, !90!]&lt;/li&gt;
  &lt;li&gt;[19, 25, 28, 33, 37, 38, 45, 52, 61, 68, 69, 73, !78!, !87!, !90!]&lt;/li&gt;
  &lt;li&gt;[19, 25, 28, 33, 37, 38, 45, 52, 61, 68, 69, 73, 78, !87!, !90!]&lt;/li&gt;
  &lt;li&gt;[19, 25, 28, 33, 37, 38, 45, 52, 61, 68, 69, 73, 78, 87, !90!]&lt;/li&gt;
  &lt;li&gt;[19, 25, 28, 33, 37, 38, 45, 52, 61, 68, 69, 73, 78, 87, 90]&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;As a result, your friend can get a result in 113 step.
Which means 19% faster than you are.&lt;/p&gt;

&lt;p&gt;To solve this problem, we call both methods as sorting algorithms.
However, it shows different perforamce as you can see.
From the next time, it will focused on the performance of the algorithm and comparison between them.&lt;/p&gt;</content><author><name>Programelot</name></author><category term="algorithm" /><summary type="html">Algorithm is a mathmatical tool to solve some problem with propal methods. For example, let’s think about a situation follows. Oneday, you’ve got a job from a city library. However, there was a tournado yesterday so all books dropped out of the shelf. Your employer calls you and asks you to clean it up in order of books’ ID. Despite of your low payment, you have no way but clean it up. Therefore, you started to think about the way to clean it up.</summary></entry><entry><title type="html">Hardness of approximation</title><link href="https://programelot.github.io/2021/05/28/Hardness-of-approximation/" rel="alternate" type="text/html" title="Hardness of approximation" /><published>2021-05-28T00:00:00+09:00</published><updated>2021-05-28T00:00:00+09:00</updated><id>https://programelot.github.io/2021/05/28/Hardness%20of%20approximation</id><content type="html" xml:base="https://programelot.github.io/2021/05/28/Hardness-of-approximation/">&lt;p&gt;MAX-E3SAT is a problem that finds a truth value assignment that satisfies the maximum number of clauses for a given a set of clause which contains exactly three literals.&lt;/p&gt;

&lt;p&gt;MAX-2SAT is a problem that finds a truth value assignment that satisfies the maximum number of clauses for a given a set of clauses which contains at most two literals.&lt;/p&gt;

&lt;p&gt;Then there exists a $\frac{7}{8}$-approximation algorithm for MAX-E3SAT problem.&lt;/p&gt;

&lt;p&gt;Proof is like follow.
If you see all of the clauses and count the existance of each literals and complementary of literals.
Then, we can pick at least half of them to be satisfied by pick $x_i$ or $\overline{x_i}$.
Then, we can cover at least $\frac{7}{8}$ of them because we have three literals for one clauses.&lt;/p&gt;

&lt;p&gt;Then, P=NP if there exists a $(\frac{7}{8} + \epsilon)$-approximation algorithm for MAX-E3SAT problem for all constant $\epsilon &amp;gt; 0$.&lt;/p&gt;

&lt;p&gt;Proof will be updated later.&lt;/p&gt;

&lt;p&gt;Then there exists no $\alpha$-approximation for MAX 2SAT for any constant $\alpha &amp;gt; \frac{433}{440}$ unless P=NP.&lt;/p&gt;

&lt;p&gt;Proof is like follow.&lt;/p&gt;

&lt;p&gt;First of all, let’s think about follow.&lt;/p&gt;

&lt;p&gt;For three literals $l1$, $l2$ and $l3$, consider the follwing set of ten clauses in terms of $l1, l2, l3$ and auxiliary variable $y$.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;$l1$&lt;/li&gt;
  &lt;li&gt;$l2$&lt;/li&gt;
  &lt;li&gt;$l3$&lt;/li&gt;
  &lt;li&gt;$\overline{l1}\lor\overline{l2}$&lt;/li&gt;
  &lt;li&gt;$\overline{l2}\lor\overline{l3}$&lt;/li&gt;
  &lt;li&gt;$\overline{l1}\lor\overline{l3}$&lt;/li&gt;
  &lt;li&gt;$y$&lt;/li&gt;
  &lt;li&gt;$l1\lor\overline{y}$&lt;/li&gt;
  &lt;li&gt;$l2\lor\overline{y}$&lt;/li&gt;
  &lt;li&gt;$l3\lor\overline{y}$&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;If $l1 \lor l2 \lor l3$ is satisfied, we can choose the value of $y$ so that exactly seven of the ten clauses are satisfied and it is impossible to satisfy more than that.
If $l1 \lor l2 \lor l3$ is not satisfied, we can choose the value of $y$ so that exactly six of the ten clauses are satisfied and it is impossible to satisfy more than that.&lt;/p&gt;

&lt;p&gt;Notice that we can have following table with number of satisfied clauses if $y$ is true.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;# true literals&lt;/th&gt;
      &lt;th&gt;# true clauses in 1~3&lt;/th&gt;
      &lt;th&gt;# true clauses in 4~6&lt;/th&gt;
      &lt;th&gt;# true clauses in 7~10&lt;/th&gt;
      &lt;th&gt;# true clauses in Total&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;7&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;7&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;6&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;If $y$ is false then number of satisfied clauses is like below.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;# true literals&lt;/th&gt;
      &lt;th&gt;# true clauses in 1~3&lt;/th&gt;
      &lt;th&gt;# true clauses in 4~6&lt;/th&gt;
      &lt;th&gt;# true clauses in 7~10&lt;/th&gt;
      &lt;th&gt;# true clauses in Total&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;6&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;7&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;7&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;6&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;As a result, maximum is follow.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;# true literals&lt;/th&gt;
      &lt;th&gt;# true clauses in 1~3&lt;/th&gt;
      &lt;th&gt;# true clauses in 4~6&lt;/th&gt;
      &lt;th&gt;# true clauses in 7~10 (best)&lt;/th&gt;
      &lt;th&gt;# true clauses in Total(best)&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;4 ($y$ as true)&lt;/td&gt;
      &lt;td&gt;7&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;3 ($y$ as true/false)&lt;/td&gt;
      &lt;td&gt;7&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;3 ($y$ as false)&lt;/td&gt;
      &lt;td&gt;7&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;3 ($y$ as false)&lt;/td&gt;
      &lt;td&gt;6&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Now. think about $m$ clauses that consistes an instance of the MAX E3SAT problem with $n$ varaibles.
We construct a MAX 2SAT instance by follow.&lt;/p&gt;

&lt;p&gt;For each $j$th clause in MAX E3SAT problem, make 10 clauses with distinct auxiliary varaible in the algorithm above.
Then, set $l1$, $l2$, $l3$ as each literals used in $j$th clause.&lt;/p&gt;

&lt;p&gt;For example, following MAX E3SAT was given.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;$x_1 \lor x_2 \lor x_3$&lt;/li&gt;
  &lt;li&gt;$\overline{x_2} \lor x_4 \lor x_5$&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Then, following is corresponding MAX 2SAT problem.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;$x_1$&lt;/li&gt;
  &lt;li&gt;$x_2$&lt;/li&gt;
  &lt;li&gt;$x_3$&lt;/li&gt;
  &lt;li&gt;$\overline{x_1}\lor\overline{x_2}$&lt;/li&gt;
  &lt;li&gt;$\overline{x_2}\lor\overline{x_3}$&lt;/li&gt;
  &lt;li&gt;$\overline{x_1}\lor\overline{x_3}$&lt;/li&gt;
  &lt;li&gt;$y_1$&lt;/li&gt;
  &lt;li&gt;$x_1\lor\overline{y_1}$&lt;/li&gt;
  &lt;li&gt;$x_2\lor\overline{y_1}$&lt;/li&gt;
  &lt;li&gt;$x_3\lor\overline{y_1}$&lt;/li&gt;
  &lt;li&gt;$\overline{x_2}$&lt;/li&gt;
  &lt;li&gt;$x_4$&lt;/li&gt;
  &lt;li&gt;$x_5$&lt;/li&gt;
  &lt;li&gt;$x_2\lor\overline{x_4}$&lt;/li&gt;
  &lt;li&gt;$\overline{x_4}\lor\overline{x_5}$&lt;/li&gt;
  &lt;li&gt;$x_2\lor\overline{x_5}$&lt;/li&gt;
  &lt;li&gt;$y_2$&lt;/li&gt;
  &lt;li&gt;$\overline{x_2}\lor\overline{y_2}$&lt;/li&gt;
  &lt;li&gt;$x_4\lor\overline{y_2}$&lt;/li&gt;
  &lt;li&gt;$x_5\lor\overline{y_2}$&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Notice that if we make it so then, it shares the optimal solution because MAX 2SAT problem can satisfies 7 of clauses iff corresponding MAX E3SAT problem’s clause satisfies and MAX 2SAT problem can satisfies 6 of clauses otherwise which is less than 7. 
For example, if $x_1$ is true and $x_4$ is true then, we can set some $y_1$ and $y_2$ to 14 of 20 becomes true.&lt;/p&gt;

&lt;p&gt;Now, run the $\alpha$-approximation algorithm for MAX 2SAT on this instance.&lt;/p&gt;

&lt;p&gt;Let’s defnine some terminologies.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;$k^{\star}$ be the number of satisfing clauses of MAX E3SAT instance from the optimal solution.&lt;/li&gt;
  &lt;li&gt;$\overline{k}$ be the number of satisfing clauses of MAX E3SAT instance from the $\alpha$-approximation algorithm’s output of MAX 2SAT problem.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Notice that we may have some auxiliary variables $y$ but we will just ignore it for $\overline{k}$.&lt;/p&gt;

&lt;p&gt;Then, MAX 2SAT instance’s optimal soltuion satisfies $7k^{\star}$ $+$ $6(m - k^{\star})$ clauses.
Which means, $\alpha(7k^{\star}$ $+$ $6(m - k^{\star}))$ $\le$ $7\overline{k}$ $+$ $6(m - \overline{k})$.
Nocie that $0$ $&amp;lt;$ $\alpha$ $\le$ $1$ because this is maximization problem.&lt;/p&gt;

&lt;p&gt;As a result, following inequality is true.&lt;/p&gt;

&lt;p&gt;$\alpha(7k^{\star}$ $+$ $6(m - k^{\star}))$ $\le$ $7\overline{k}$ $+$ $6(m - \overline{k})$ $\leftrightarrow$
$\alpha(k^{\star}$ $+$ $6m)$ $\le$ $\overline{k}$ $+$ $6m$ $\leftrightarrow$
$\alpha k^{\star}$ $+$ $\alpha 6m$ $\le$ $\overline{k}$ $+$ $6m$ $\leftrightarrow$
$\alpha k^{\star}$ $+$ $\alpha 6m$ $-$ $6m$ $\le$ $\overline{k}$ $\leftrightarrow$
$\alpha k^{\star}$ $+$ $6(\alpha  - 1)m$ $\le$ $\overline{k}$ $\leftrightarrow$
$\alpha k^{\star}$ $-$ $6(1 - \alpha)m$ $\le$ $\overline{k}$.&lt;/p&gt;

&lt;p&gt;Now, we already have $\frac{7}{8}$-approximation algorithm.
Therefore, $k^{\star}$ $\ge$ $\frac{7}{8}m$ and $\frac{8}{7}k^{\star}$ $\ge$ $m$.&lt;/p&gt;

&lt;p&gt;As a result, $\overline{k}$ $\ge$
$\alpha k^{\star}$ $-$ $6(1 - \alpha)m$ $\ge$
$\alpha k^{\star}$ $-$ $6(1 - \alpha)\frac{8}{7}k^{\star}$ $=$
$(\alpha - 6(1 - \alpha)\frac{8}{7})k^{\star}$ $=$
$(\frac{55}{7}\alpha - \frac{48}{7})k^{\star}$.&lt;/p&gt;

&lt;p&gt;Notice that $m$ $\le$ $\frac{8}{7}k^{\star}$ $\leftrightarrow$
$-$ $\frac{8}{7}k^{\star}$ $\le$ $-$ $m$ $\leftrightarrow$
$-$ $6(1 - \alpha)\frac{8}{7}k^{\star}$ $\le$ $-$ $6(1 - \alpha)m$.&lt;/p&gt;

&lt;p&gt;If there is $\alpha &amp;gt; \frac{433}{440}$,
$\overline{k}$ $\ge$
$(\frac{55}{7}\alpha - \frac{48}{7})k^{\star}$ $&amp;gt;$
$(\frac{55}{7}\frac{433}{440} - \frac{48}{7})k^{\star}$ $=$
$(\frac{7}{8})k^{\star}$.&lt;/p&gt;

&lt;p&gt;Now, we show that such $\alpha$-approximation for MAX 2SAT can be used to give $(\frac{7}{8} + \epsilon)$-approximation algorithm for MAX-E3SAT problem for some constant $\epsilon &amp;gt; 0$ and $\alpha &amp;gt; \frac{433}{440}$.
Which is a contradiction.
Therefore, there is no such an approximation algorithm.&lt;/p&gt;</content><author><name>Programelot</name></author><category term="algorithm" /><category term="approximation" /><summary type="html">MAX-E3SAT is a problem that finds a truth value assignment that satisfies the maximum number of clauses for a given a set of clause which contains exactly three literals.</summary></entry><entry><title type="html">Approximation algorithm(13) - Buy-at-bulk network design</title><link href="https://programelot.github.io/2021/05/26/Approximation-algorithm(13)/" rel="alternate" type="text/html" title="Approximation algorithm(13) - Buy-at-bulk network design" /><published>2021-05-26T00:00:00+09:00</published><updated>2021-05-26T00:00:00+09:00</updated><id>https://programelot.github.io/2021/05/26/Approximation%20algorithm(13)</id><content type="html" xml:base="https://programelot.github.io/2021/05/26/Approximation-algorithm(13)/">&lt;p&gt;In the real world, it is usually cheaper when you buy some thing in a bulk because of the delivery costs.
Now think about a undirected graph $G$ $=$ $(V,E)$ with length $l_e$ $\ge$ $0$ for all $e$ $\in$ $E$.
This problem requires $k$ pairs of vertices $(s_i,t_i)$ and demand $d_i$.
One thing that makes this problem interesting is that there is a cost function $f(u)$ such that satisfies following.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;$f(0)$ $=$ $0$&lt;/li&gt;
  &lt;li&gt;$f$ is non-decreasing.&lt;/li&gt;
  &lt;li&gt;$f$ is subadditive which means $f(x + y)$ $\le$ $f(x)$ $+$ $f(y)$ for all $x, y$ $\in$ $\mathbb{N}$&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Now problem asks to find $k$ paths from $s_i$ to $t_i$ with capacity $c:E \rightarrow \mathbb{N}$
to minimize $\sum\limits_{e \in E}f(c_e)l_e$
such that for any edge we can send $d_i$ units of commodity from $s_i$ to $t_i$ at the same time without violating $c$.&lt;/p&gt;

&lt;p&gt;Notice that this algorithm can be solved in polynomial time if $G$ is a tree.
The reason is like follow.
If you think about any possible path on a tree, there is a unique path from $u$ to $v$ where $u,v$ $\in$ $V$.
Therefore, solution is just find a unique path and set the capacity and that’s all.
Notice that this means it’s not just in polynomial time but it gives a trivial unique solution.&lt;/p&gt;

&lt;p&gt;Now, let’s consider the following algorithm.&lt;/p&gt;

&lt;div class=&quot;algTab&quot;&gt;
    $\operatorname{for}$ each pair of vertices $u,v$ in $V$&lt;div class=&quot;algTab&quot;&gt;
        $P_{uv}$ be the shortest path from $u$ to $v$ in $E$
    &lt;/div&gt;
    $d_{uv}$ be the length of shortest path from $u$ to $v$.&lt;br /&gt;
    Find a tree metric $(V',T)$ that approximates $d$&lt;br /&gt;
    $\operatorname{for}$ each pair of vertices $u,v$ in $V$&lt;div class=&quot;algTab&quot;&gt;
        $P'_{uv}$ be the shortest path from $u$ to $v$ in $T$
    &lt;/div&gt;
    $c_e \leftarrow 0$ for all $e$ $\in$ $E$&lt;br /&gt;
    $\operatorname{for}$ each pair $s_i, t_i$&lt;div class=&quot;algTab&quot;&gt;
        $\operatorname{for}$ each edge $(u,v)$ in $P'_{s_i t_i}$&lt;div class=&quot;algTab&quot;&gt;
            $\operatorname{for}$ each edge $e$ in $P_{u v}$&lt;div class=&quot;algTab&quot;&gt;
                Increase $c_e$ $\leftarrow$ $c_e$ $+$ $d_i$ 
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    return $c$
&lt;/div&gt;

&lt;p&gt;First of all, we need to show that there is a tree metric.
Therefore we need to show that $d$ is a pseudometric.
Notice that most of properties are trivial but only triangular inequality need to be more detial.
Now, let’s think about any path between $(x,y)$ and $(y,z)$.
Then, $d_{xy}$ $+$ $d_{yz}$ $=$
$\sum\limits_{e \in P_{xy}}l_e$ $+$ $\sum\limits_{e \in P_{yz}}l_e$ $=$
$\sum\limits_{e \in P_{xy} \cup P_{yz}}l_e$ $\ge$ 
$\sum\limits_{e \in P_{xz}}l_e$ $=$ 
$d_{xz}$.
Notice that concatinating path from $x$ to $y$ and path from $y$ to $z$ is a path from $x$ to $z$.
Which means at least longer or equal than “shortest” path from $x$ to $z$ in other world $P_{xy} \cup P_{yz}$ $\supseteq$ $P_{xz}$.&lt;/p&gt;

&lt;p&gt;Now, problem is that we need to go through some $x$ that was not in $V$ but is in $V’$.
Therefore, we need to remove every such vertices.&lt;/p&gt;

&lt;p&gt;Here is another algorithm that gives a tree metric from a tree metric.&lt;/p&gt;
&lt;div class=&quot;algTab&quot;&gt;
    $\operatorname{fit}$(V, V', T)&lt;div class=&quot;algTab&quot;&gt;
        $T' \leftarrow T$&lt;br /&gt;
        $\operatorname{while}$ $\exists v \in V$ and $v$'s parent $w$ such that $w$ was not a left node of $T$&lt;div class=&quot;algTab&quot;&gt;
            Merge $v$ and $w$ to $v$
        &lt;/div&gt;
        Multiply the length of every edge of $T'$ by 4&lt;br /&gt;
        return $(V, T')$
    &lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;If given a tree metric $T$ can be like follow.&lt;br /&gt;&lt;/p&gt;
&lt;canvas id=&quot;canvas1&quot; width=&quot;200&quot; height=&quot;200&quot; style=&quot;border:1px solid #d3d3d3;&quot;&gt;
    Your browser does not support the HTML canvas tag.&lt;/canvas&gt;
&lt;p&gt;&lt;br /&gt;
Then, other tree metric $T’$ can be like follow.&lt;br /&gt;&lt;/p&gt;
&lt;canvas id=&quot;canvas2&quot; width=&quot;200&quot; height=&quot;200&quot; style=&quot;border:1px solid #d3d3d3;&quot;&gt;
    Your browser does not support the HTML canvas tag.&lt;/canvas&gt;
&lt;p&gt;&lt;br /&gt;
&lt;script language=&quot;javascript&quot;&gt;
    c = document.getElementById(&quot;canvas1&quot;);
    ctx = c.getContext(&quot;2d&quot;);
    ctx.fillStyle = &quot;white&quot;;
    ctx.fillRect(0, 0, c.width, c.height);
  	ctx.beginPath();
    ctx.fillStyle = &quot;black&quot;;
  	ctx.moveTo(175, 170);
  	ctx.lineTo(125, 110);
  	ctx.lineTo(100, 40);
  	ctx.lineTo(75, 110);
  	ctx.lineTo(25, 170);
  	ctx.moveTo(75, 110);
  	ctx.lineTo(75, 170);
  	ctx.moveTo(75, 110);
  	ctx.lineTo(125, 170);
    ctx.stroke();
    ctx.fillStyle = &quot;white&quot;;
    ctx.beginPath();
    ctx.arc(25, 170, 20, 0, 2*Math.PI);
    ctx.stroke();
    ctx.fill();
    ctx.beginPath();
    ctx.arc(75, 170, 20, 0, 2*Math.PI);
    ctx.stroke();
    ctx.fill();
    ctx.beginPath();
    ctx.arc(125, 170, 20, 0, 2*Math.PI);
    ctx.stroke();
    ctx.fill();
    ctx.beginPath();
    ctx.arc(175, 170, 20, 0, 2*Math.PI);
    ctx.stroke();
    ctx.fill();
    ctx.beginPath();
    ctx.arc(75, 110, 20, 0, 2*Math.PI);
    ctx.stroke();
    ctx.fill();
    ctx.beginPath();
    ctx.arc(125, 110, 20, 0, 2*Math.PI);
    ctx.stroke();
    ctx.fill();
    ctx.beginPath();
    ctx.arc(100, 40, 20, 0, 2*Math.PI);
    ctx.stroke();
    ctx.fill();
    ctx.textAlign = &quot;center&quot;;
    ctx.fillStyle = &quot;red&quot;;
    ctx.font = &quot;15px Arial&quot;;
    ctx.fillText('4', 80, 80);
    ctx.fillText('4', 120, 80);
    ctx.fillText('2', 160, 140);
    ctx.fillText('2', 110, 140);
    ctx.fillText('2', 65, 145);
    ctx.fillText('2', 45, 140);
    ctx.fillText('{A,B,C,D}', 100, 40);
    ctx.fillText('{A,B,C}', 75, 110);
    ctx.fillText('{D}', 125, 110);
    ctx.fillText('{A}', 25, 170);
    ctx.fillText('{B}', 75, 170);
    ctx.fillText('{C}', 125, 170);
    ctx.fillText('{D}', 175, 170);
    c = document.getElementById(&quot;canvas2&quot;);
    ctx = c.getContext(&quot;2d&quot;);
    ctx.fillStyle = &quot;white&quot;;
    ctx.fillRect(0, 0, c.width, c.height);
  	ctx.beginPath();
    ctx.fillStyle = &quot;black&quot;;
  	ctx.moveTo(100, 40);
  	ctx.lineTo(75, 110);
  	ctx.lineTo(25, 170);
  	ctx.moveTo(75, 110);
  	ctx.lineTo(125, 170);
    ctx.stroke();
    ctx.fillStyle = &quot;white&quot;;
    ctx.beginPath();
    ctx.arc(25, 170, 20, 0, 2*Math.PI);
    ctx.stroke();
    ctx.fill();
    ctx.beginPath();
    ctx.arc(125, 170, 20, 0, 2*Math.PI);
    ctx.stroke();
    ctx.fill();
    ctx.beginPath();
    ctx.arc(75, 110, 20, 0, 2*Math.PI);
    ctx.stroke();
    ctx.fill();
    ctx.beginPath();
    ctx.arc(100, 40, 20, 0, 2*Math.PI);
    ctx.stroke();
    ctx.fill();
    ctx.textAlign = &quot;center&quot;;
    ctx.fillStyle = &quot;red&quot;;
    ctx.font = &quot;15px Arial&quot;;
    ctx.fillText('16', 70, 80);
    ctx.fillText('8', 110, 140);
    ctx.fillText('8', 45, 140);
    ctx.fillText('{A}', 25, 170);
    ctx.fillText('{B}', 75, 110);
    ctx.fillText('{C}', 125, 170);
    ctx.fillText('{D}', 100, 40);
&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;Then, this algorithm returns a tree metric on $V$ such that $T_{uv}$ $\le$ 
$T’_{uv}$ $\le$ 
$4T_{uv}$ for all $u,v$ $\in$ $V$.
Notice that $T$ above is a result of original tree metric approximation algorithm.
Proof is like follow.&lt;/p&gt;

&lt;p&gt;First, $T’_{uv}$ $\le$ $T_{uv}$ untill we multiply 4 because we only merge the vertices.
Therefore, $T’_{uv}$ $\le$ $4T_{uv}$ is true at the end of the algorithm.&lt;/p&gt;

&lt;p&gt;Now, let’s recap some facts from the tree metric $T$.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;$\mathcal{L}_n$ is the level of the $n$. Notice that level of root node is $\log_2 \Delta$ and level of leaf node is $0$.&lt;/li&gt;
  &lt;li&gt;$\mathcal{A}_{uv}$ is the least common ancestor of $u$ and $v$.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Then, $T_{uv}$ $=$ 
$2\sum_{k=1}^{\mathcal{L}_{\mathcal{A}_{uv}}}2^k$ $=$ 
$2^{\mathcal{L}_{\mathcal{A}_{uv}} + 2} - 4$ is true.&lt;/p&gt;

&lt;p&gt;Now, let’s think about the smallest possible length for $T’_{uv}$.
Then, $u$ and $v$ will go only to the parent and the possible most go is right below $\mathcal{A}_{uv}$.
One of $u$ and $v$ may be can be merged to $\mathcal{A}_{uv}$ but not other one of $u$ and $v$ can be $\mathcal{A}_{uv}$.
As a result, one of edge from $\mathcal{A}_{uv}$ to child will still left to exist.
Therefore, $T’_{uv}$ $\ge$
$4 \cdot 2^{\mathcal{L}_{\mathcal{A}_{uv}}}$ $=$ 
$2^{\mathcal{L}_{\mathcal{A}_{uv}} + 2}$ $\ge$
$2^{\mathcal{L}_{\mathcal{A}_{uv}} + 2} - 4$ $=$
$T_{uv}$
Therefore, claim holds.&lt;/p&gt;

&lt;p&gt;Notice that this means $d_{uv}$ $\le$ $T_{uv}$ $\le$ $T’_{uv}$ and $E[T’_{uv}]$ $\le$ $E[4T_{uv}]$ $=$ $4E[T_{uv}]$ $\le$ $O(\ln \left\vert V \right\vert)d_{uv}$.
Therefore, $d_{uv}$ $\le$ $T’_{uv}$ and $E[T’_{uv}]$ $\le$ $O(\ln \left\vert V \right\vert)d_{uv}$.&lt;/p&gt;

&lt;p&gt;Now, think about the algorithm follow.&lt;/p&gt;

&lt;div class=&quot;algTab&quot;&gt;
    $\operatorname{for}$ each pair of vertices $u,v$ in $V$&lt;div class=&quot;algTab&quot;&gt;
        $P_{uv}$ be the shortest path from $u$ to $v$ in $E$
    &lt;/div&gt;
    $d_{uv}$ be the length of shortest path from $u$ to $v$.&lt;br /&gt;
    Find a tree metric $(V',T)$ that approximates $d$&lt;br /&gt;
    $(V,T')$ $\leftarrow$ $\operatorname{fit}(V, V', T)$&lt;br /&gt;
    $\operatorname{for}$ each pair of vertices $u,v$ in $V$&lt;div class=&quot;algTab&quot;&gt;
        $P'_{uv}$ be the shortest path from $u$ to $v$ in $T'$
    &lt;/div&gt;
    $c_e \leftarrow 0$ for all $e$ $\in$ $E$&lt;br /&gt;
    $\operatorname{for}$ each pair $s_i, t_i$&lt;div class=&quot;algTab&quot;&gt;
        $\operatorname{for}$ each edge $(u,v)$ in $P'_{s_i t_i}$&lt;div class=&quot;algTab&quot;&gt;
            $\operatorname{for}$ each edge $e$ in $P_{u v}$&lt;div class=&quot;algTab&quot;&gt;
                Increase $c_e$ $\leftarrow$ $c_e$ $+$ $d_i$ 
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    return $c$
&lt;/div&gt;

&lt;p&gt;Then this algorithm is a $O(\log n)$-approximation algorithm.
Proof is like follow.&lt;/p&gt;

&lt;p&gt;Let’s denote some terminologies.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;$P^{\star}_{u v}$ is the shortest path between $u$ and $v$ from the optimal solution.&lt;/li&gt;
  &lt;li&gt;$c^{\star}_e$ for $e$ $\in$ $E$ is the capacity of $e$ from the optimal solution.&lt;/li&gt;
  &lt;li&gt;$\operatorname{OPT}$ is the optimal solution; $\operatorname{OPT}$ $=$ 
$\sum\limits_{e \in E}f(\sum\limits_{i = 1 : e \in P^{\star}_{s_i t_i}}^{k} d_i)l_e$ $=$ 
$\sum\limits_{(u,v) \in E} f(\sum\limits_{i = 1 : (u,v) \in P^{\star}_{s_i t_i}}^{k} d_i)d_{uv}$ $=$
$\sum\limits_{(u,v) \in E} f(\sum\limits_{i = 1}^{k} d_i \mathbb{1}((u,v) \in P^{\star}_{s_i t_i})) d_{uv}$.&lt;/li&gt;
  &lt;li&gt;$P’_{u v}$ is the unique shortest path between $u$ and $b$ from the $T’$.&lt;/li&gt;
  &lt;li&gt;$P^{S}_{u v}$ is a path that changes each edge $(x,y)$ in $P^{\star}_{u v}$ to $P’_{x, y}$.&lt;/li&gt;
  &lt;li&gt;$\operatorname{OPT’}$ is the solution from $P^{S}_{s_i t_i}$; $\operatorname{OPT’}$ $=$
$\sum\limits_{e \in T’}f(\sum\limits_{i = 1 : e \in P^{S}_{s_i t_i}}^{k} d_i)l_e$ $=$
$\sum\limits_{(x,y) \in T’} f(\sum\limits_{i = 1}^{k} d_i \sum\limits_{(u,v) \in E} \mathbb{1}((u,v) \in P^{\star}_{s_i t_i} \text{ and } (x,y) \in P’_{u v}))T’_{xy}$.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Notice that $P^{S}_{s_i t_i}$ may not be simple.
Then, $E[\operatorname{OPT’}]$ $=$
$E[\sum\limits_{(x,y) \in T’} f(\sum\limits_{i = 1}^{k} d_i \sum\limits_{(u,v) \in E} \mathbb{1}((u,v) \in P^{\star}_{s_i t_i} \text{ and } (x,y) \in P’_{u v}))T’_{xy}]$ $\le$
$E[\sum\limits_{(x,y) \in T’} \sum\limits_{(u,v) \in E} f(\sum\limits_{i = 1}^{k}d_i \mathbb{1}((u,v) \in P^{\star}_{s_i t_i} \text{ and } (x,y) \in P’_{u v}))T’_{xy}]$ $=$
$E[\sum\limits_{(u,v) \in E} \sum\limits_{(x,y) \in T’} f(\sum\limits_{i = 1}^{k}d_i \mathbb{1}((u,v) \in P^{\star}_{s_i t_i} \text{ and } (x,y) \in P’_{u v}))T’_{xy}]$ $=$
$E[\sum\limits_{(u,v) \in E} \sum\limits_{(x,y) \in P’_{u v}} f(\sum\limits_{i = 1}^{k}d_i \mathbb{1}((u,v) \in P^{\star}_{s_i t_i}))T’_{xy}]$ $=$
$\sum\limits_{(u,v) \in E} E[ \sum\limits_{(x,y) \in P’_{u v}} f(\sum\limits_{i = 1}^{k}d_i \mathbb{1}((u,v) \in P^{\star}_{s_i t_i}))T’_{xy}]$ $=$
$\sum\limits_{(u,v) \in E} E[ f(\sum\limits_{i = 1}^{k}d_i \mathbb{1}((u,v) \in P^{\star}_{s_i t_i})) \sum\limits_{(x,y) \in P’_{u v}}T’_{xy}]$ $=$
$\sum\limits_{(u,v) \in E} f(\sum\limits_{i = 1}^{k} d_i \mathbb{1}((u,v) \in P^{\star}_{s_i t_i})) E[ \sum\limits_{(x,y) \in P’_{u v}}T’_{xy}]$ $=$
$\sum\limits_{(u,v) \in E} f(\sum\limits_{i = 1}^{k} d_i \mathbb{1}((u,v) \in P^{\star}_{s_i t_i})) E[T’_{uv}]$ $\le$
$\sum\limits_{(u,v) \in E} f(\sum\limits_{i = 1}^{k} d_i \mathbb{1}((u,v) \in P^{\star}_{s_i t_i})) O(\ln \left\vert V \right\vert)d_{uv}$ $=$
$O(\ln \left\vert V \right\vert) \sum\limits_{(u,v) \in E} f(\sum\limits_{i = 1}^{k} d_i \mathbb{1}((u,v) \in P^{\star}_{s_i t_i})) d_{uv}$ $=$
$O(\ln \left\vert V \right\vert) \operatorname{OPT}$.&lt;/p&gt;

&lt;p&gt;Notice that following facts.
First inequality holds because $f$ is subadditive.
Third equality holds because $P’_{uv}$ $\in$ $T’$.
Sixth equality holds because $f(\sum\limits_{i = 1}^{k} d_i \mathbb{1}((u,v) \in P^{\star}_{s_i t_i}))$ is independent from $u,v$.
Seventh equality holds because $\sum\limits_{(x,y) \in P’_{u v}}T’_{xy}$ is the distance from $u$ to $v$.
Therefore claim holds.&lt;/p&gt;

&lt;p&gt;Simiallary, following is true.&lt;/p&gt;

&lt;p&gt;Now let’s denote $\operatorname{ALG}$ as the value of the output solution.
Then, $\operatorname{ALG}$ $=$
$\sum\limits_{(u,v) \in E} f(\sum\limits_{i = 1}^{k} d_i \sum\limits_{(x,y) \in T’} \mathbb{1}((x,y) \in P’_{s_i t_i} \text{ and } (u,v) \in P_{xy}))d_{uv}$ $\le$
$\sum\limits_{(u,v) \in E} \sum\limits_{(x,y) \in T’} f(\sum\limits_{i = 1}^{k} d_i \mathbb{1}((x,y) \in P’_{s_i t_i} \text{ and } (u,v) \in P_{xy}))d_{uv}$ $=$
$\sum\limits_{(x,y) \in T’} \sum\limits_{(u,v) \in E} f(\sum\limits_{i = 1}^{k} d_i \mathbb{1}((x,y) \in P’_{s_i t_i} \text{ and } (u,v) \in P_{xy}))d_{uv}$ $=$
$\sum\limits_{(x,y) \in T’} \sum\limits_{(u,v) \in P_{xy}} f(\sum\limits_{i = 1}^{k} d_i \mathbb{1}((x,y) \in P’_{s_i t_i}))d_{uv}$ $=$
$\sum\limits_{(x,y) \in T’} f(\sum\limits_{i = 1}^{k} d_i \mathbb{1}((x,y) \in P’_{s_i t_i})) \sum\limits_{(u,v) \in P_{xy}}d_{uv}$ $=$
$\sum\limits_{(x,y) \in T’} f(\sum\limits_{i = 1}^{k} d_i \mathbb{1}((x,y) \in P’_{s_i t_i})) d_{xy}$ $\le$
$\sum\limits_{(x,y) \in T’} f(\sum\limits_{i = 1}^{k} d_i \mathbb{1}((x,y) \in P’_{s_i t_i})) T’_{xy}$ $\le$
$\sum\limits_{(x,y) \in T’} f(\sum\limits_{i = 1}^{k} d_i \sum\limits_{(u,v) \in E} \mathbb{1}((u,v) \in P^{\star}_{s_i t_i} \text{ and } (x,y) \in P’_{u v}))T’_{xy}$ $=$
$\operatorname{OPT’}$.&lt;/p&gt;

&lt;p&gt;All eqaulities and inequalities except last ineuqality can be proven in the same way with above.
Therefore, we need to show only last inequality holds.&lt;/p&gt;

&lt;p&gt;Proof for “$\sum\limits_{(x,y) \in T’} f(\sum\limits_{i = 1}^{k} d_i \mathbb{1}((x,y) \in P’_{s_i t_i})) T’_{xy}$ $\le$
$\sum\limits_{(x,y) \in T’} f(\sum\limits_{i = 1}^{k} d_i \sum\limits_{(u,v) \in E} \mathbb{1}((u,v) \in P^{\star}_{s_i t_i} \text{ and } (x,y) \in P’_{u v}))T’_{xy}$” is like follow.&lt;/p&gt;

&lt;p&gt;Let’s think about “$\mathbb{1}((x,y) \in P’_{s_i t_i})$” and 
“$\sum\limits_{(u,v) \in E} \mathbb{1}((u,v) \in P^{\star}_{s_i t_i} \text{ and } (x,y) \in P’_{u v})$” for some $x, y, i$.&lt;/p&gt;

&lt;p&gt;Then first one is $1$ if $(x,y) \in P’_{s_i t_i}$ and $0$ otherwise.
Therefore, there is nothing to show if $(x,y) \not\in P’_{s_i t_i}$.
Now, let’s assume that $(x,y) \in P’_{s_i t_i}$.
Then, $P^{\star}_{s_i t_i}$ should include at least $(s_i,t_i)$ or longer path from $s_i$ to $t_i$ for any $i$.
Which means the cardinarity of $\{(u,v) \in P^{\star}_{s_i t_i} \text{ and } (x,y) \in P’_{u v}\}$ should be bigger or equal than $1$.
Therefore, claim holds.
Notice that concatinating $(u,v) \in P^{\star}_{s_i t_i}$ in $T’$ will be a valid path from $u$ to $v$.
Therefore, $(x,y)$ should be in some where in there.&lt;/p&gt;

&lt;p&gt;As a result, $\operatorname{ALG}$ $\le$ $\operatorname{OPT’}$ $\le$ $O(\ln \left\vert V \right\vert) \operatorname{OPT}$.
Therefore claim holds.&lt;/p&gt;

&lt;p&gt;Notice that algorithm runs in a polynomial time.&lt;/p&gt;</content><author><name>Programelot</name></author><category term="algorithm" /><category term="approximation" /><summary type="html">In the real world, it is usually cheaper when you buy some thing in a bulk because of the delivery costs. Now think about a undirected graph $G$ $=$ $(V,E)$ with length $l_e$ $\ge$ $0$ for all $e$ $\in$ $E$. This problem requires $k$ pairs of vertices $(s_i,t_i)$ and demand $d_i$. One thing that makes this problem interesting is that there is a cost function $f(u)$ such that satisfies following.</summary></entry><entry><title type="html">Useful mathematical tools</title><link href="https://programelot.github.io/2021/05/19/Useful-mathematical-tools/" rel="alternate" type="text/html" title="Useful mathematical tools" /><published>2021-05-19T00:00:00+09:00</published><updated>2021-05-19T00:00:00+09:00</updated><id>https://programelot.github.io/2021/05/19/Useful%20mathematical%20tools</id><content type="html" xml:base="https://programelot.github.io/2021/05/19/Useful-mathematical-tools/">&lt;ol&gt;
  &lt;li&gt;$\ln n$ $\le$ $\sum\limits_{k = 1}^{n} \frac{1}{k}$ $\le$ $\ln n$ $+$ $1$ for $n$ $\in$ $\mathbb{Z}^{+}$&lt;/li&gt;
  &lt;li&gt;$\sum\limits_{k = 1}^{n}ar^{k-1}$ $=$ $a\frac{r^{n} - 1}{r - 1}$ if $r$ $\neq$ $1$, $n$ $\in$ $\mathbb{Z}$&lt;/li&gt;
&lt;/ol&gt;</content><author><name>Programelot</name></author><category term="algorithm" /><category term="approximation" /><summary type="html">$\ln n$ $\le$ $\sum\limits_{k = 1}^{n} \frac{1}{k}$ $\le$ $\ln n$ $+$ $1$ for $n$ $\in$ $\mathbb{Z}^{+}$ $\sum\limits_{k = 1}^{n}ar^{k-1}$ $=$ $a\frac{r^{n} - 1}{r - 1}$ if $r$ $\neq$ $1$, $n$ $\in$ $\mathbb{Z}$</summary></entry><entry><title type="html">Approximation of metrics by tree metrics</title><link href="https://programelot.github.io/2021/05/19/tree-metrics/" rel="alternate" type="text/html" title="Approximation of metrics by tree metrics" /><published>2021-05-19T00:00:00+09:00</published><updated>2021-05-19T00:00:00+09:00</updated><id>https://programelot.github.io/2021/05/19/tree%20metrics</id><content type="html" xml:base="https://programelot.github.io/2021/05/19/tree-metrics/">&lt;p&gt;For a given vertices $V$ and distance $V \times V \rightarrow \mathcal{R} : d$.
$(V,d)$ is so called a metric if following properties are hold.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;$d_{uv}$ $\ge$ $0$ for all $u,v$ $\in$ $V$&lt;/li&gt;
  &lt;li&gt;$d_{uv}$ $=$ $0$ iff $u = v$&lt;/li&gt;
  &lt;li&gt;$d_{uv}$ $=$ $d_{vu}$ for all $u,v$ $\in$ $V$&lt;/li&gt;
  &lt;li&gt;(Triangular inequality) $d_{uv}$ $\le$ $d_{uw}$ $+$ $d_{wv}$ for all $u,v,w$ $\in$ $V$&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Notice that we say it is a pseudometric if property 2 changes to “$d_{uv}$ $=$ $0$ if $u = v$”.&lt;/p&gt;

&lt;p&gt;A tree metic $(V’, T)$ for a set of vertices $V$ is a tree $T$ defined on a set of nodes $V’ \supseteq V$, whoese edges are given non negative lengths.
For $u,v$ $\in$ $V’$, let $T_{uv}$ denote the length of the unique path between $u$ and $v$ in $T$.&lt;/p&gt;

&lt;p&gt;Notice that tree matrix is a matric.
It is trivial to be hold for 1 ~ 3.
For 4, if there is a path $u$ to $w$ and $w$ to $v$, then concatinating them is a path from $u$ to $v$.
It will have the length equal or less than sum of each path because there could be a cycle and it can be removed.&lt;/p&gt;

&lt;p&gt;Given a metric $d$ on $V$, we say a tree metric $(V’, T)$ is a $\operatorname{tree metic embedding}$ of distortion $\alpha$ if $d_{uv}$ $\le$ $T_{uv}$ $\le$ $\alpha d_{uv}$ for all $u,v$ $\in$ $V$.&lt;/p&gt;

&lt;p&gt;However, do we even have any approximation for it in every time?
Yes, if we have gigantic distortion.
However, it’s no with some distortion.
In fact it is known that there is no tree metric has distortion less than $\frac{n - 1}{8}$ for some metric $d$ on $n$ vertices.
However there is a good theorem.&lt;/p&gt;

&lt;p&gt;Given a metric $d$ on $V$ such that $d_{uv}$ $\ge$ $1$ for all $u$ $\neq$ $v$, there exists a randomized algorithm that finds a tree metric $(V’, T)$ such that for all $u, v$ $\in$ $V$, $d_{uv}$ $\le$ $T_{uv}$ and $E[T_{uv}]$ $\le$ $O(\ln \left\vert V \right\vert)d_{uv}$.
Notice that this randomized algorithm picks a tree metric from a given graph.
Proof is like follow.&lt;/p&gt;

&lt;p&gt;Consider the following algorithm where $B(x, r)$ is a hypersphere with the center at $x$ and radius of $r$.&lt;/p&gt;
&lt;div class=&quot;algTab&quot;&gt;
    Pick $r_0$ $\in$ $[\frac{1}{2}, 1)$ uniformly at random&lt;br /&gt;
    Choose $\Delta$ as the smallest power of two greater or equal than $2\max_{u,v \in V}d_{uv}$&lt;br /&gt;
    Let $r_i$ $=$ $2^ir_0$ for $1$ $\le$ $i$ $\le$ $\log_2 \Delta$&lt;br /&gt;
    Pick a permutation $\pi$ of $v$ uniformly at random&lt;br /&gt;
    $\mathcal{C}(\log_2 \Delta) \leftarrow \{V\}$&lt;br /&gt;
    Create a node corresponding to $V$ and make it the root node&lt;br /&gt;
    $\operatorname{for}$ $i \leftarrow \log_2 \Delta, \log_2 \Delta - 1, \cdots, 1$&lt;div class=&quot;algTab&quot;&gt;
        $\mathcal{C}(i - 1) \leftarrow \emptyset$&lt;br /&gt;
        $\operatorname{for}$ $C \in \mathcal{C}(i)$&lt;div class=&quot;algTab&quot;&gt;
            $S \leftarrow C$&lt;br /&gt;
            $\operatorname{for}$ $j \leftarrow 1, 2, \cdots, \left\vert V \right\vert$&lt;div class=&quot;algTab&quot;&gt;
                $\operatorname{if}$ $B(\pi(j), r_{i-1})$ $\cap$ $S$ $\neq$ $\emptyset$&lt;div class=&quot;algTab&quot;&gt;
                    Add $\{B(\pi(j), r_{i-1}) \cap S\}$ to $\mathcal{C}(i -1)$&lt;br /&gt;
                    $S$ $\leftarrow$ $S$ $-$ $(B(\pi(j), r_{i-1}) \cap S)$
                &lt;/div&gt;
            &lt;/div&gt;
            Create nodes corresponding to each set in $\mathcal{C}(i -1)$ and attach each node to the node in $\mathcal{C}(i)$ corresponding to its superset by an edge of length $2^i$
        &lt;/div&gt;
    &lt;/div&gt;
    $V' \leftarrow$ all nodes in $\bigcup\limits_{k = 0}^{\log_2 \Delta}\mathcal{C}(k)$&lt;br /&gt;
    $T \leftarrow$ all edges between $\mathcal{C}(k)$ and $\mathcal{C}(k - 1)$ for all $1$ $\le$ $k$ $\le$ $\log_2 \Delta$&lt;br /&gt;
    return $(V', T)$ 
&lt;/div&gt;

&lt;p&gt;For an example, following graph’s result will be like follow.&lt;/p&gt;

&lt;p&gt;If given metric is like follow.&lt;br /&gt;&lt;/p&gt;
&lt;canvas id=&quot;canvas1&quot; width=&quot;200&quot; height=&quot;200&quot; style=&quot;border:1px solid #d3d3d3;&quot;&gt;
    Your browser does not support the HTML canvas tag.&lt;/canvas&gt;
&lt;p&gt;&lt;br /&gt;
Returned tree metric can be like follow.&lt;br /&gt;&lt;/p&gt;
&lt;canvas id=&quot;canvas2&quot; width=&quot;200&quot; height=&quot;200&quot; style=&quot;border:1px solid #d3d3d3;&quot;&gt;
    Your browser does not support the HTML canvas tag.&lt;/canvas&gt;
&lt;p&gt;&lt;br /&gt;
&lt;script language=&quot;javascript&quot;&gt;
    let c = document.getElementById(&quot;canvas1&quot;);
    let ctx = c.getContext(&quot;2d&quot;);
    ctx.fillStyle = &quot;white&quot;;
    ctx.fillRect(0, 0, c.width, c.height);
    ctx.fillStyle = &quot;white&quot;;
    ctx.beginPath();
    ctx.arc(100, 100, 80, 0, 2*Math.PI);
    ctx.stroke();
    ctx.beginPath();
    ctx.arc(100, 180, 10, 0, 2*Math.PI);
    ctx.stroke();
    ctx.fill();
    ctx.beginPath();
    ctx.arc(100, 20, 10, 0, 2*Math.PI);
    ctx.stroke();
    ctx.fill();
    ctx.beginPath();
    ctx.arc(20, 100, 10, 0, 2*Math.PI);
    ctx.stroke();
    ctx.fill();
    ctx.beginPath();
    ctx.arc(180, 100, 10, 0, 2*Math.PI);
    ctx.stroke();
    ctx.fill();
    ctx.textAlign = &quot;center&quot;;
    ctx.fillStyle = &quot;red&quot;;
    ctx.font = &quot;20px Arial&quot;;
    ctx.fillText('A', 100, 180);
    ctx.fillText('B', 100, 20);
    ctx.fillText('C', 20, 100);
    ctx.fillText('D', 180, 100);
    ctx.fillText('1', 44, 44);
    ctx.fillText('1', 156, 44);
    ctx.fillText('1', 44, 156);
    ctx.fillText('1', 156, 156);
    c = document.getElementById(&quot;canvas2&quot;);
    ctx = c.getContext(&quot;2d&quot;);
    ctx.fillStyle = &quot;white&quot;;
    ctx.fillRect(0, 0, c.width, c.height);
  	ctx.beginPath();
    ctx.fillStyle = &quot;black&quot;;
  	ctx.moveTo(175, 170);
  	ctx.lineTo(125, 110);
  	ctx.lineTo(100, 40);
  	ctx.lineTo(75, 110);
  	ctx.lineTo(25, 170);
  	ctx.moveTo(75, 110);
  	ctx.lineTo(75, 170);
  	ctx.moveTo(75, 110);
  	ctx.lineTo(125, 170);
    ctx.stroke();
    ctx.fillStyle = &quot;white&quot;;
    ctx.beginPath();
    ctx.arc(25, 170, 20, 0, 2*Math.PI);
    ctx.stroke();
    ctx.fill();
    ctx.beginPath();
    ctx.arc(75, 170, 20, 0, 2*Math.PI);
    ctx.stroke();
    ctx.fill();
    ctx.beginPath();
    ctx.arc(125, 170, 20, 0, 2*Math.PI);
    ctx.stroke();
    ctx.fill();
    ctx.beginPath();
    ctx.arc(175, 170, 20, 0, 2*Math.PI);
    ctx.stroke();
    ctx.fill();
    ctx.beginPath();
    ctx.arc(75, 110, 20, 0, 2*Math.PI);
    ctx.stroke();
    ctx.fill();
    ctx.beginPath();
    ctx.arc(125, 110, 20, 0, 2*Math.PI);
    ctx.stroke();
    ctx.fill();
    ctx.beginPath();
    ctx.arc(100, 40, 20, 0, 2*Math.PI);
    ctx.stroke();
    ctx.fill();
    ctx.textAlign = &quot;center&quot;;
    ctx.fillStyle = &quot;red&quot;;
    ctx.font = &quot;15px Arial&quot;;
    ctx.fillText('4', 80, 80);
    ctx.fillText('4', 120, 80);
    ctx.fillText('2', 160, 140);
    ctx.fillText('2', 110, 140);
    ctx.fillText('2', 65, 145);
    ctx.fillText('2', 45, 140);
    ctx.fillText('{A,B,C,D}', 100, 40);
    ctx.fillText('{A,B,C}', 75, 110);
    ctx.fillText('{D}', 125, 110);
    ctx.fillText('{A}', 25, 170);
    ctx.fillText('{B}', 75, 170);
    ctx.fillText('{C}', 125, 170);
    ctx.fillText('{D}', 175, 170);
&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;Now, following is true if we call the deepest nodes as level 0 and level $i$’s parent as level $i + 1$.
Note that each node at level 0 corresponding to a singleton and every vertex in $V$ appears exactly once.
The reason is that there can’t be more than center itself because $r_0$ $&amp;lt;$ $1$ $\le$ $d_{uv}$ for all $u,v$ $\in$ $V$.
Notice that every vertex at level $i$ is belongs to a hyper sphere of radius $r_i$ and centered by one of vertex in side of the set.
Which also means that level $\log_2 \Delta$ will contain entire $V$ because $r_{\log_2 \Delta}$ $=$ $2^{\log_2 \Delta} r_0$ $\ge$ $2^{\log_2 \Delta} \frac{1}{2}$ $=$ $\Delta \frac{1}{2}$ $\ge$ $2\max_{u,v \in V}d_{uv}\frac{1}{2}$ $=$ $\max_{u,v \in V}d_{uv}$.&lt;/p&gt;

&lt;p&gt;Now, let’s denote some terminologies for a node $n$ in the $(V’, T)$.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;$\mathcal{L}_n$ is the level of the $n$. Notice that level of root node is $\log_2 \Delta$ and level of leaf node is $0$.&lt;/li&gt;
  &lt;li&gt;$\mathcal{S}_n$ is the set of vertices which the corresponding hyper sphere includes.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Then, there are some facts.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;$d_{yz}$ $\le$ $2r_{\mathcal{L}_n}$ for any $y,z$ $\in$ $\mathcal{S}_n$ becuase it should be in the same hyper sphere.&lt;/li&gt;
  &lt;li&gt;For any $u,v$ $\in$ $V$, they can’t belongs to the same node at level $[\log_2 d_{uv}] - 1$ because otherwise $d_{uv}$ $\le$ $2r_{[\log_2 d_{uv}] - 1}$ $=$ $2 \cdot 2^{[\log_2 d_{uv}] - 1}r_0$ $=$ $2^{[\log_2 d_{uv}]}r_0$ $\le$ $2^{\log_2 d_{uv}}r_0$ $=$ $d_{uv}r_0$ $&amp;lt;$ $d_{uv}$ which is a contradiction.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Then, $T_{uv}$ $\ge$ $d_{uv}$ is true.
Proof is like follow.
If $d_{uv}$ $&amp;lt;$ $4$ then, $T_{uv}$ $\ge$ $d_{uv}$ because $T_{uv}$ $\ge$ $4$.
Notice that $T_{uv}$ $\ge$ $4$ is true because all edges in the $T$ is bigger or equal than $2$ and there should be at least one parent to go $v$ from $u$.
Now, other cases are $d_{uv}$ $\ge$ $4$.
Frist, $d_{uv}$ $\le$ $\sum\limits_{k = 0}^{[\log_2 d_{uv}]} 2^k$ because RHS is bigger than a binary representation of $d_{uv}$.
Then, $d_{uv}$ $\le$ $\sum\limits_{k = 0}^{[\log_2 d_{uv}]} 2^k$ $=$ $\sum\limits_{k = 1}^{[\log_2 d_{uv}]} 2^k$ $+$ $1$ $\le$ $\sum\limits_{k = 1}^{[\log_2 d_{uv}]} 2^k$ $+$ $\sum\limits_{k = 1}^{[\log_2 d_{uv}]} 2^k$ $=$ $2\sum\limits_{k = 1}^{[\log_2 d_{uv}]} 2^k$ $\le$ $T_{uv}$.
Notice that last inequality comes from the fact 2 above.
If we think about path from $u$ to $v$, it should go to at least level $[\log_2 d_{uv}]$ because it can’t belongs to the same node untill level $[\log_2 d_{uv}] - 1$.
Also, $2\sum\limits_{k = 1}^{[\log_2 d_{uv}]} 2^k$ is a sum of length from $u$ to $v$ via level $[\log_2 d_{uv}]$.
Therefore, claim holds.&lt;/p&gt;

&lt;p&gt;Now there are only one thing to show that $E[T_{uv}]$ $\le$ $O(\ln \left\vert V \right\vert)d_{uv}$.&lt;/p&gt;

&lt;p&gt;To show this, there some terminologies to define.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;$\mathcal{A}_{uv}$ is the least common ancestor of $u$ and $v$.&lt;/li&gt;
  &lt;li&gt;We say $w$ settles the pair of $u$ and $v$ on $i$ if $w$ is the first vertex in permutation $\pi$ such that at least one of $u$ and $v$ is in the hypersphere $B(w, r_i)$.&lt;/li&gt;
  &lt;li&gt;We say $w$ cut $u$ and $v$ on level $i$ if exactly one of $u$ and $v$ is in the hypersphere $B(w, r_i)$.&lt;/li&gt;
  &lt;li&gt;$X_{iw}(u,v)$ be the event that $w$ cuts $(u, v)$ on level $i$.&lt;/li&gt;
  &lt;li&gt;$S_{iW}(u,v)$ be the event that $w$ settles $(u, v)$ on level $i$.&lt;/li&gt;
  &lt;li&gt;$\mathbb{1}(x)$ is an indicator fuction such that $1$ if $x$ is true $0$ otherwise.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;First, $T_{uv}$ $=$ 
$2\sum_{k=1}^{\mathcal{L}_{\mathcal{A}_{uv}}}2^k$ $=$ 
$2(2^{\mathcal{L}_{\mathcal{A}_{uv}} + 1} - 2)$ $=$ 
$2^{\mathcal{L}_{\mathcal{A}_{uv}} + 2} - 4$ $\le$ 
$2^{\mathcal{L}_{\mathcal{A}_{uv}} + 2}$.&lt;/p&gt;

&lt;p&gt;Then, $T_{uv}$ $\le$ $\max\limits_{i = 0}^{\log_2 \Delta - 1} \mathbb{1}(\exists X_{iw}(u,v) \cap S_{iw}(u,v) \text{ for } w \in V) 2^{i + 3}$.&lt;/p&gt;

&lt;p&gt;Notice that $\operatorname{argmax}\limits_{i = 0}^{\log_2 \Delta - 1} \mathbb{1}(\exists X_{iw}(u,v) \cap S_{iw}(u,v) \text{ for } w \in V)2^{i + 3}$ is the $\mathcal{A}_{uv}$.&lt;/p&gt;

&lt;p&gt;Therefore, $T_{uv}$ $\le$ $\max\limits_{i = 0}^{\log_2 \Delta - 1} \mathbb{1}(\exists X_{iw}(u,v) \cap S_{iw}(u,v) \text{ for } w \in V) 2^{i + 3}$
$\le$ $\sum\limits_{w \in V}\sum\limits_{i = 0}^{\log_2 \Delta - 1} \mathbb{1}(\exists X_{iw}(u,v) \cap S_{iw}(u,v)) 2^{i + 3}$.&lt;/p&gt;

&lt;p&gt;Now if we go back to the algorithm, there are two random events at the algorithm which are “picking $r_0$” and “picking a random permutation $\pi$”.
Therefore, we can average on certain path to select $T_{uv}$.
Then, $E[T_{uv}]$ $\le$ $\sum\limits_{w \in V}\sum\limits_{i = 0}^{\log_2 \Delta - 1} Pr[X_{iw}(u,v) \cap S_{iw}(u,v)] 2^{i + 3}$.
Notice that existance of $X_{iw}(u,v) \cap S_{iw}(u,v)$ for $w$ $\in$ $V$ on level $i$ will be depend on random varaibles and other things are indepedent with the random variable.&lt;/p&gt;

&lt;p&gt;Now, let’s consider followings.&lt;/p&gt;

&lt;p&gt;With out loosing generality, let’s assume that $d_{uw}$ $\le$ $d_{vw}$ for $w$ that cuts $u$ and $v$ on level $i$.
Then, $d_{uw}$ $\le$ $r_i$ $&amp;lt;$ $d_{vw}$ because $u$ should be in $B(w, r_i)$ and $v$ shouldn’t.
With above, we need to select $r_i$ uniformly at random with $2^ir_0$.
Then we will pick $r_i$ in $[2^{i-1},2^i)$ because we will pick $r_0$ in $[\frac{1}{2}, 1)$. 
Now, let’s think about the $Pr[X_{iw}(u,v)]$.
Then, $Pr[X_{iw}(u,v)]$ $=$ $\frac{\left\vert [2^{i-1}, 2^i) \cap [d_{uw}, d_{vw}) \right\vert}{\left\vert [2^{i-1}, 2^i \right\vert}$ $=$ $\frac{\left\vert [2^{i-1}, 2^i) \cap [d_{uw}, d_{vw}) \right\vert}{2^{i-1}}$.
As a result, $\sum\limits_{i=0}^{\log_2 \Delta - 1}Pr[X_{iw}(u,v)]2^{i + 3}$ $=$ 
$\sum\limits_{i=0}^{\log_2 \Delta - 1}\frac{\left\vert [2^{i-1}, 2^i) \cap [d_{uw}, d_{vw}) \right\vert}{2^{i-1}}2^{i + 3}$ $=$
$\sum\limits_{i=0}^{\log_2 \Delta - 1}\frac{2^{i + 3}}{2^{i-1}}\left\vert [2^{i-1}, 2^i) \cap [d_{uw}, d_{vw}) \right\vert$ $=$
$2^4\sum\limits_{i=0}^{\log_2 \Delta - 1}\left\vert [2^{i-1}, 2^i) \cap [d_{uw}, d_{vw}) \right\vert$ $=$
$16\sum\limits_{i=0}^{\log_2 \Delta - 1}\left\vert [2^{i-1}, 2^i) \cap [d_{uw}, d_{vw}) \right\vert$ $=$
$16\left\vert [d_{uw}, d_{vw}) \right\vert$ for any $w$.
Notice that $\bigcup\limits_{i=0}^{\log_2 \Delta - 1}[2^{i-1}, 2^i)$ $=$ $[2^{-1}, 2^{\log_2 \Delta - 1})$ $=$ $[2^{-1}, 2^{-1}\Delta)$ $=$ $[2^{-1}, 2^{-1}2\max_{u,v \in V}d_{uv})$ $=$ $[2^{-1}, \max_{u,v \in V}d_{uv})$ $\supseteq$ set of possible $d_{uv}$ for all $u,v$ $\in$ $V$.
Which means it will see all possible area.
Notice that $d_{uv}$ $\ge$ $1$ and $Pr[X_{iw}(u,v)]$ means probability that $w$ on level $i$ will cut $u$ and $v$.
As a result, $Pr[X_{iw}(u,v)]$ $=$ $16\left\vert [d_{uw}, d_{vw}) \right\vert$ $=$ $16(d_{vw} - d{uw})$ $\le$ $16(d_{vu} + d_{uw} - d_{uw})$ $=$ $16d_{vu}$ $=$ $16d_{uv}$ from the triangular inequality.&lt;/p&gt;

&lt;p&gt;Now, let’s think about list $\mathbb{L}$ from $V$ such that sorted in the order $\min(d_{ux}, d_{vx})$ for $x$ $\in$ $\mathbb{L}$.
Now, think about 2 things.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Some $w$ $\in$ $V$ such that $w$ cuts $u$ and $v$.&lt;/li&gt;
  &lt;li&gt;Let’s denote $w$’s level as $i$.&lt;/li&gt;
  &lt;li&gt;Let’s denote $w$’s index in $\mathbb{L}$ is $\mathcal{I}_w$&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Then, one of $u$ or $v$ should be in $B(z, r_i)$ for any $z$ that has less index than $\mathcal{I}_w$.
Notice that $\min(d_{uz}, d_{vz})$ $\le$ $\min(d_{uw}, d_{vw})$ $\le$ $r_i$ because it is sorted by $\min(d_{ux}, d_{vx})$ and $w$ cuts $u$ and $v$.
Then, $Pr[S_{iw}(u,v) \vert X_{iw}(u,v)]$ $\le$ $\frac{1}{\mathcal{I}_w}$ because $w$ need to be placed in $\pi$ more previous than all such $z$s.
Notice that there are at least $\mathcal{I}_w$ candiadates that can cut $u$ and $v$ and $w$ need to be the first on $\pi$ to settle $u$ and $v$.
Moreover, $\sum\limits_{w \in V}Pr[S_{iw}(u,v) \vert X_{iw}(u,v)]$ $\le$ $\sum\limits_{w \in V}\frac{1}{\mathcal{I}_w}$ for a fixed $i$.
Notice that if we fix $i$, $\mathcal{I}_w$ will be some arbitrary order of vertices.
However that will be still fixed in some way after set-up random variables.
Which means $\sum\limits_{w \in V}Pr[S_{iw}(u,v) \vert X_{iw}(u,v)]$ $=$ $\sum\limits_{w \in V : \mathcal{I}_w = k, w \text{ cuts } u \text{ and } v}\frac{1}{k}$ $=$ $\sum\limits_{k = 1 : \mathcal{I}_w = k, w \text{ cuts } u \text{ and } v}^{\left\vert V \right\vert}\frac{1}{k}$ $\le$ $\sum\limits_{k = 1}^{\left\vert V \right\vert}\frac{1}{k}$ $\le$ $\ln \left\vert V \right\vert$ $+$ $1$.
Finally, notice that $\mathcal{I}_w$ doesn’t depend on $i$ because it only depend on $\min(d_{ux}, d_{vx})$.
Infact, it doesn’t even depend on any random varaible.&lt;/p&gt;

&lt;p&gt;Now, following 4 things are true for summary.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;$E[T_{uv}]$ $\le$ $\sum\limits_{w \in V}\sum\limits_{i = 0}^{\log_2 \Delta - 1} Pr[X_{iw}(u,v) \cap S_{iw}(u,v)] 2^{i + 3}$&lt;/li&gt;
  &lt;li&gt;$\sum\limits_{i = 0}^{\log_2 \Delta - 1} Pr[X_{iw}(u,v)]2^{i + 3}$ $\le$ $16d_{uv}$&lt;/li&gt;
  &lt;li&gt;$Pr[S_{iw}(u,v) \vert X_{iw}(u,v)]$ $\le$ $\frac{1}{\mathcal{I}_w}$&lt;/li&gt;
  &lt;li&gt;$\sum\limits_{w \in V} \frac{1}{\mathcal{I}_w}$ $\le$ $\ln \left\vert V \right\vert$ $+$ $1$&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;As a result, $E[T_{uv}]$ $\le$
$\sum\limits_{w \in V}\sum\limits_{i = 0}^{\log_2 \Delta - 1} Pr[X_{iw}(u,v) \cap S_{iw}(u,v)] 2^{i + 3}$ $=$
$\sum\limits_{w \in V}\sum\limits_{i = 0}^{\log_2 \Delta - 1} Pr[S_{iw}(u,v) \vert X_{iw}(u,v)]Pr[X_{iw}(u,v)] 2^{i + 3}$ $=$
$\sum\limits_{w \in V}\sum\limits_{i = 0}^{\log_2 \Delta - 1} Pr[X_{iw}(u,v)]2^{i + 3} Pr[S_{iw}(u,v) \vert X_{iw}(u,v)]$ $\le$
$\sum\limits_{w \in V}\sum\limits_{i = 0}^{\log_2 \Delta - 1} Pr[X_{iw}(u,v)]2^{i + 3}\frac{1}{\mathcal{I}_w}$ $=$
$\sum\limits_{w \in V}\frac{1}{\mathcal{I}_w}\sum\limits_{i = 0}^{\log_2 \Delta - 1} Pr[X_{iw}(u,v)]2^{i + 3}$ $\le$
$\sum\limits_{w \in V}\frac{1}{\mathcal{I}_w}16d_{uv}$ $=$
$16d_{uv}\sum\limits_{w \in V} \frac{1}{\mathcal{I}_w}$ $\le$
$16d{uv}(\ln \left\vert V \right\vert + 1)$ $=$ $O(\ln \left\vert V \right\vert)d_{uv}$.&lt;/p&gt;

&lt;p&gt;Therefore, claim holds.&lt;/p&gt;</content><author><name>Programelot</name></author><category term="algorithm" /><category term="approximation" /><summary type="html">For a given vertices $V$ and distance $V \times V \rightarrow \mathcal{R} : d$. $(V,d)$ is so called a metric if following properties are hold.</summary></entry><entry><title type="html">Graph coloring</title><link href="https://programelot.github.io/2021/05/15/Graph-coloring/" rel="alternate" type="text/html" title="Graph coloring" /><published>2021-05-15T00:00:00+09:00</published><updated>2021-05-15T00:00:00+09:00</updated><id>https://programelot.github.io/2021/05/15/Graph%20coloring</id><content type="html" xml:base="https://programelot.github.io/2021/05/15/Graph-coloring/">&lt;p&gt;We need some definitions and theorems to discuss about the coloring.&lt;/p&gt;

&lt;h2 id=&quot;definitions&quot;&gt;Definitions&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;A coloring of graph $G$ is an assignment of colors to the vertices of $G$.
In this case, it can be considered as the assignemnts of sets like vertex 1 to set 1 and vetex 2 to set 3 and so-on.&lt;/li&gt;
  &lt;li&gt;A graph is is $k$-coloring if each vertex is assigned to exactly one of $k$ colors.&lt;/li&gt;
  &lt;li&gt;A coloring is proper if no two adjacent vertices are assigned to the same color.&lt;/li&gt;
  &lt;li&gt;A graph is so-called $k$-colorable if it has a proper $k$-coloring.&lt;/li&gt;
  &lt;li&gt;We say $g(n)$ $=$ $\tilde{O}(f(n))$ if there exists some constant $c$ $\ge$ $0$ such that $g(n)$ $=$ $O(f(n))\ln^c$.
This is some extention that ignoring logarithmic terms.&lt;/li&gt;
  &lt;li&gt;We say coloring is a semicoloring if at most $\frac{\left\vert V \right\vert}{4}$ edges have endpoints with the same color.
Notice that semicoloring don’t need to be proper.
It allows $\frac{\left\vert V \right\vert}{4}$ edges to be collide.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;theorems&quot;&gt;Theorems&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;There is a polynomial time algorithm to check 2-colorable.
Notice that we can do it by DFS and checking there is some pair of vertices that colors collide.&lt;/li&gt;
  &lt;li&gt;It is known to be NP-hard to decide if a graph is 3-colorable.&lt;/li&gt;
  &lt;li&gt;It is known to be NP-hard to decide if a graph is 3-colorable or any of its proper coloring requires at least five colors.
This means input will give like 3-colorable, 5-colorable, 6-colorable, etc..
There will no 4-colorable inputs.&lt;/li&gt;
  &lt;li&gt;It is known to be NP-hard to find a 3-coloring from a 3-colorable graph.
Notice that if there is such an algorithm in polynomial time then running that algorithm and checking the result are enough to solve 3-colorable problem.&lt;/li&gt;
  &lt;li&gt;A graph with maximum degree $\delta$ can be $(\delta + 1)$-colored in polynomial time.
Notice that all of vertices never run out of colors in this case because even all the neighbors use seperate colors, there are still one color to use.&lt;/li&gt;
  &lt;li&gt;3-colorable graph can be $O(\sqrt{n})$-colored in polynomial time for $n$ as the number of vertices.&lt;/li&gt;
  &lt;li&gt;There exists a polynomial time random algorithm that finds a semicoloring with $4\Delta^{\log_3 2}$ colors at least $\frac{1}{2}$ probability where $\Delta$ is the maximum degree of a graph with.&lt;/li&gt;
  &lt;li&gt;There is a polynomial algorithm that finds $\tilde{O}(n^{\log_6 2})$-coloring of a given 3-colorable graph at least $\frac{1}{2}$ probability.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;proof-of-theorems&quot;&gt;Proof of theorems&lt;/h2&gt;

&lt;p&gt;Theorem 6 can be done by following algorithm.&lt;/p&gt;
&lt;div class=&quot;algTab&quot;&gt;
    $\operatorname{while} \exists$ a vertex $v$ with at least degree $\sqrt{n}$&lt;div class=&quot;algTab&quot;&gt;
        Choose three new colors $c_1, c_2, c_3$&lt;br /&gt;
        Color $v$ with $c_1$&lt;br /&gt;
        Color neighbors of $v$ with $c_2, c_3$&lt;br /&gt;
        Remove colored vertices
    &lt;/div&gt;
    Color the rest of graph with $\sqrt{n}$ new colors
&lt;/div&gt;
&lt;p&gt;Notice that the neighbors of $v$ can be colored with 2 colors in each iteration because given graph is a 3-colorable graph.
The reason is that all of neighbor of $v$ can’t be $c_1$ if we select $v$ as $c_1$.
Then, it’s a 2-coloring problem which can be solve in polynomial time.
With that, $v$ and its neighbors are using distinct from other vertices because it producess new colors.
Notice that we can remove it because it uses independent color sets.
Now, it uses just $\sqrt{n}$ color at the last.
Therefore it’s enough to show there are at most $O(\sqrt{n})$ iteration for “ $\operatorname{while} \exists$ a vertex $v$ with at least degree $\sqrt{n}$”.
With that, it removes at least $\sqrt{n}I$ vetices from graph if we denote $I$ as the number of such an iteration because each vertices has $\sqrt{n}$ degree.
However, we can’t remove more vetices than number of vertices at the beginning.
Therefore, $\sqrt{n}I$ $\le$ $n$.
As a result, $I$ $\le$ $\sqrt{n}$.
Notice that algorithm uses at most $4\sqrt{n}$ colors and it runs in a polynomial time.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;Theorem 7 can be done by following algorithm.&lt;/p&gt;

&lt;p&gt;Consider the following vector program for given graph $G$ $=$ $(V,E)$.
Let $n$ $=$ $\left\vert V \right\vert$
Minimize $\lambda$&lt;br /&gt;
such that
    $v_i \cdot v_j \le \lambda$ for all $(i, j) \in E$&lt;br /&gt;
    $v_i \cdot v_i = 1$ for all $i \in V$&lt;br /&gt;
    $v_i \in \mathcal{R}^n$ for all $i \in V$&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;Then, there is a feasible solution such that $v_i \cdot v_j$ $=$ $-\frac{1}{2}$ for all $(i,j) \in E$ if given graph is a 3-colorable graph.
Proof is like follow.&lt;/p&gt;

&lt;p&gt;Consider an equilateral triangle inscribed in the intersection of the unit hypersphere and a hyperplane containing the origin.
Fix a 3-coloring and assign one of the three vertices of the triangle as the vector of each vetex in $V$ so that vertices are assigned the same vector iff they are assigned the same color.
Notice that all $v_i$ will be on this hypersphere because “$v_i \cdot v_i = 1$ for all $i \in V$”.
Now, we have $v_i \cdot v_j$ $=$ $\left\vert v_i \right\vert \left\vert v_j \right\vert \cos (\frac{2\pi}{3})$ $=$ $-\frac{1}{2}$.
Notice that angle is $\frac{2\pi}{3}$ because it’s an equilateral triangle.&lt;/p&gt;

&lt;p&gt;Then, we can design an algorithm like follow.&lt;/p&gt;
&lt;div class=&quot;algTab&quot;&gt;
    Solve algorithm above to obtain optimal solution $v_1, \cdots, v_n$&lt;br /&gt;
    Choose vector $r_1, \cdots, r_t$ independently and uniformly at random from the unit hypersphere where $t = 2 + \log_3 \Delta$.&lt;br /&gt;
    Divides the hyper sphere into $2^t$ different regions by half space $H_i = \{x | x \cdot r_i \ge 0\}$ for $0$ $\le$ $i$ $\le$ $t$&lt;br /&gt;
    Assign a distinct color for all vectices in each resign.
&lt;/div&gt;

&lt;p&gt;Polynomial running time of semidefinitive program/random picking will be updated later.
Then, all other process will be in the polynomial time.
Notice that this algorithm uses $2^t$ $=$ $2^{2 + \log_3 \Delta}$ $=$ $4 \times 2^{\log_3 \Delta}$ $=$ $4 {\Delta}^{\log_3 2}$ colors.
Therefore, it’s enough to show that this makes a semicoloring with $\frac{1}{2}$ probability.&lt;/p&gt;

&lt;p&gt;Now, let’s think about edge $e$ $=$ $(v_i, v_j)$.
With this, consider some $H_k$ and $r^{\star}_k$.
Which $r^{\star}_k$ is the projection of $r_k$ on to the plane defined by $v_i, v_j, 0$.
Then, $v_i \cdot r_k$ $=$ $v_i \cdot r^{\star}_k$ and $v_i \cdot r_k$ $=$ $v_i \cdot r^{\star}_k$.
Notice that $r_k$ can be decomposed to $r^{\star}_k$ and $r^{\circ}_k$.
Then, $v_i \cdot r_k$ $=$ 
$v_i \cdot (r^{\star}_k + r^{\circ}_k)$ $=$ 
$v_i \cdot r^{\star}_k$ $+$ $v_i \cdot r^{\circ}_k$ $=$
$v_i \cdot r^{\star}_k$.
This works in the same way for $v_j$ either.
Now, $Pr[\text{Both } v_i \text{ and } v_j \text{ are in the } H_k]$ $=$
$Pr[\text{Both } v_i \cdot r_k \text{ and } v_j \cdot r_k \text{ has the same sign}]$ $=$ 
$Pr[\text{Both } v_i \cdot r^{\star}_k \text{ and } v_j \cdot r^{\star}_k \text{ has the same sign}]$&lt;/p&gt;

&lt;p&gt;Then, $Pr[\text{Both } v_i \cdot r^{\star}_k \text{ and } v_j \cdot r^{\star}_k \text{ has the same sign}]$ $=$ $\frac{\pi - \theta}{\pi}$ which $\theta$ is the angle between $v_i$ and $v_j$.
Proof is like follow.
Let’s denote $\theta_i, \theta_j, \theta_k$ as the angle of $v_i, v_j, r^{\star}_k$.
Then, there are two cases for $\theta_k$ which both $v_i \cdot r^{\star}_k$ and $v_j \cdot r^{\star}_k$ are positive or negative.
With this two cases, there are 2 cases per each case for each of them from criteria “$\theta_i = \theta_j + \pi$” to choose the range of possible angle.
Therefore, there are 4 cases in total.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;$\theta_j - \frac{\pi}{2}$ $\le$ $\theta_k$ $\le$ $\theta_i + \frac{\pi}{2}$ if $\theta_i$ $\le$ $\theta_j$ $\le$ $\theta_i$ $+$ $\pi$ and both $v_i \cdot r^{\star}_k$ and $v_j \cdot r^{\star}_k$ are positive.&lt;/li&gt;
  &lt;li&gt;$\theta_j + \frac{\pi}{2}$ $\le$ $\theta_k$ $\le$ $\theta_i + \frac{3\pi}{2}$ if $\theta_i$ $\le$ $\theta_j$ $\le$ $\theta_i$ $+$ $\pi$ and both $v_i \cdot r^{\star}_k$ and $v_j \cdot r^{\star}_k$ are negative.&lt;/li&gt;
  &lt;li&gt;$\theta_i - \frac{\pi}{2}$ $\le$ $\theta_k$ $\le$ $\theta_j + \frac{\pi}{2}$ if $\theta_i$ $-$ $\pi$ $\le$ $\theta_j$ $\le$ $\theta_i$ and both $v_i \cdot r^{\star}_k$ and $v_j \cdot r^{\star}_k$ are positive.&lt;/li&gt;
  &lt;li&gt;$\theta_i + \frac{\pi}{2}$ $\le$ $\theta_k$ $\le$ $\theta_j + \frac{3\pi}{2}$ if $\theta_i$ $-$ $\pi$ $\le$ $\theta_j$ $\le$ $\theta_i$ and both $v_i \cdot r^{\star}_k$ and $v_j \cdot r^{\star}_k$ are negative.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Then, we can know claim holds in each cases.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;$2\pi Pr[\text{Both } v_i \cdot r^{\star}_k \text{ and } v_j \cdot r^{\star}_k \text{ has the same sign}]$ $=$
$(\theta_i + \frac{\pi}{2})$ $-$ $(\theta_j - \frac{\pi}{2})$ $+$ $(\theta_i + \frac{3\pi}{2})$ - $(\theta_j + \frac{\pi}{2})$  $=$
$2(\theta_i - \theta_j)$ $+$ $2\pi$ $=$
$2(\pi + \theta_i - \theta_j)$ $=$
$2(\pi - (\theta_j - \theta_i))$
if $\theta_i$ $\le$ $\theta_j$ $\le$ $\theta_i$ $+$ $\pi$.
As a result, $Pr[\text{Both } v_i \cdot r^{\star}_k \text{ and } v_j \cdot r^{\star}_k \text{ has the same sign}]$ $=$ 
$\frac{\pi - (\theta_j - \theta_i)}{\pi}$.
Therefore claim holds in this case.&lt;/li&gt;
  &lt;li&gt;$2\pi Pr[\text{Both } v_i \cdot r^{\star}_k \text{ and } v_j \cdot r^{\star}_k \text{ has the same sign}]$ $=$
$(\theta_j + \frac{\pi}{2})$ $-$ $(\theta_i - \frac{\pi}{2})$ $+$ $(\theta_j + \frac{3\pi}{2})$ $-$ $(\theta_i + \frac{\pi}{2})$ $=$
$2(\theta_j - \theta_i)$ $+$ $2\pi$ $=$
$2(\pi + \theta_j - \theta_i)$ $=$
$2(\pi - (\theta_i - \theta_j))$
if $\theta_i$ $-$ $\pi$ $\le$ $\theta_j$ $\le$ $\theta_i$.
As a result, $Pr[\text{Both } v_i \cdot r^{\star}_k \text{ and } v_j \cdot r^{\star}_k \text{ has the same sign}]$ $=$ 
$\frac{\pi - (\theta_i - \theta_j)}{\pi}$.
Therefore claim holds in this case.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Notice that $Pr[\text{Both } v_i \text{ and } v_j \text{ are in the } H_k]$ $=$
$\frac{\pi - \theta}{\pi}$ $=$
$1$ $-$ $\frac{\theta}{\pi}$ $=$
$1$ $-$ $\frac{\arccos(v_i \cdot v_j)}{\pi}$ $=$
$1$ $-$ $\frac{1}{\pi}\arccos(v_i \cdot v_j)$.&lt;/p&gt;

&lt;p&gt;Therefore, $Pr[\text{Both } i \text{ and } j \text{ assigned to the same color}]$ $=$ 
$Pr[\text{Both } v_i \text{ and } v_j \text{ are in the same reigon for all half space}]$ $=$ 
$(1 - \frac{1}{\pi}\arccos(v_i \cdot v_j))^t$.
With above, there are two facts from semidefinitive program and proof above.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;$v_i \cdot v_j \le \lambda$ for all $(i, j) \in E$&lt;/li&gt;
  &lt;li&gt;There is a feasible solution such that $v_i \cdot v_j$ $=$ $-\frac{1}{2}$ for all $(i,j) \in E$&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Now let’s denote semidefinitive program optimum’s $\lambda$ as ${\lambda}^{\star}$.
Then, ${\lambda}^{\star}$ $\le$ $-\frac{1}{2}$ because semidefinitive program was minimization problem.&lt;/p&gt;

&lt;p&gt;Therefore, $Pr[\text{Both } i \text{ and } j \text{ assigned to the same color}]$ $=$
$(1 - \frac{1}{\pi}\arccos(v_i \cdot v_j))^t$ $\le$
$(1 - \frac{1}{\pi}\arccos({\lambda}^{\star}))^t$ $\le$
$(1 - \frac{1}{\pi}\arccos(-\frac{1}{2}))^t$ $=$
$(1 - \frac{1}{\pi}\frac{2\pi}{3})^t$ $=$
$(1 - \frac{2}{3})^t$ $=$
$(\frac{1}{3})^{2 + \log_3 \Delta}$ $=$
$\frac{1}{9\Delta}$.&lt;/p&gt;

&lt;p&gt;Notice that $\arccos x$ is a monotonic decreasing function for $-1$ $\le$ $x$ $\le$ $1$.
Therefore, $1$ $-$ $\frac{1}{\pi}\arccos x$ is a monotonic increasing function.&lt;/p&gt;

&lt;p&gt;Now, sum of degree is $2\left\vert E \right\vert$ and possible maximum sum of degree is $n\Delta$.
Therefore, $2\left\vert E \right\vert$ $\le$ $n\Delta$ which means $\frac{\left\vert E \right\vert}{\Delta}$ $\le$ $\frac{n}{2}$.
As a result, expected number of edges whose endpoints are colred the same is at most $\left\vert E \right\vert \frac{1}{9\Delta}$ $=$ $\frac{\left\vert E \right\vert}{9\Delta}$ $\le$ $\frac{n}{18}$.&lt;/p&gt;

&lt;p&gt;Then, $Pr[X \ge \frac{n}{4}]$ $\le$ $\frac{E[X]}{n/4}$ $=$ $\frac{4}{n}E[X]$ $\le$ $\frac{4}{n}\frac{n}{18}$ $=$ $\frac{2}{9}$ $\le$ $\frac{1}{2}$ with markov’s inequality where $X$ denotes number of edges where endpoiunts are colored the same.
Therefore claim holds.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;Theorem 8 can be done by following algorithm.
Let $\sigma = n^{\log_6 3}$.&lt;/p&gt;
&lt;div class=&quot;algTab&quot;&gt;
    Let's call the below part as &quot;part 1&quot;&lt;div class=&quot;algTab&quot;&gt;
        $\operatorname{while} \exists$ a vertex $v$ with degree $\ge$ $\sigma$&lt;div class=&quot;algTab&quot;&gt;
            Color $v$ and it's neighbors using three new colors&lt;br /&gt;
            Remove the colored vertices
        &lt;/div&gt;
    &lt;/div&gt;
    Let's call the below part as &quot;part 2&quot;&lt;div class=&quot;algTab&quot;&gt;
        $\operatorname{while}$ the graph is not empty, repeat at most $\log_2 n$ times&lt;div class=&quot;algTab&quot;&gt;
           Try running Algorithm at theorem 7 with $[\log_2(\log_2 n)] + 1$ times to find a semicoloring&lt;br /&gt;
           $R \leftarrow$ endpoints of edges whose endpoints are colored the same&lt;br /&gt;
           Color $V - R$ according to the semicoloring, using new colors&lt;br /&gt;
           Remove the colored vetices
        &lt;/div&gt;
    &lt;/div&gt;
    Color the remaining vertices with distinct new colors
&lt;/div&gt;

&lt;p&gt;Now, it is trivial that this algorithm runs in a polynomial time.
Therefore, it is enough to show it returns $\tilde{O}(n^{\log_6 2})$-coloring at least $\frac{1}{2}$ probability.
Now, let’s think about part 1.
Then, maximum number of iteration is at most $[\frac{n}{\sigma}] + 1$ because it remvoes at least $\sigma$ vertices at once.
Therefore, color used at part 1 is at most $3([\frac{n}{\sigma}] + 1)$.
Now, let’s think about part 2.
Left part of graph has at most $\sigma$ degree because we removed every possible vertices with more than degree $\sigma$.
Now, let’s denote the maximum of degree after part 1 as $\Delta$ and the number of vertices as $n’$.
If we see each iteration, it fails to find a semicoloring with $(\frac{1}{2})^{[\log_2(\log_2 n)] + 1}$ probability.
Which is $(\frac{1}{2})^{[\log_2(\log_2 n)] + 1}$ $=$
$(2)^{-[\log_2(\log_2 n)] - 1}$ $\le$
$(2)^{-\log_2(\log_2 n) - 1}$ $=$
$(2)^{-\log_2(\log_2 n)}\frac{1}{2}$ $=$
$(2)^{\log_2(\log_2 n)^{-1}}\frac{1}{2}$ $=$
$(\log_2 n)^{-1}\frac{1}{2}$ $=$
$\frac{1}{2\log_2 n}$.
Therefore, it fails at most $\frac{1}{2\log_2 n}$ probability.
As a result, this algorithm success to find a semicoloring in every iteration at least $(1 - \frac{1}{2\log_2 n})^{\log_2 n}$ $\ge$ $\frac{1}{2}$ probability if $n$ $\ge$ $2$.&lt;/p&gt;

&lt;p&gt;Proof is like follow.
Notice that if we change $log_2 x$ to $t$ then $(1 - \frac{1}{2\log_2 n})^{\log_2 n}$ $=$ $(1 - \frac{1}{2t})^{t}$.
Now it can be derivated easily about $t$ and result will be $(1 - \frac{1}{2t})(\ln(1 - \frac{1}{2t}) + \frac{1}{2t - 1})$.
Notice that $t \ge 1$.
Then, $1 - \frac{1}{2t} \ge 0$ because $t \ge 1$.
For the other part, $\ln(1 - \frac{1}{2t})$ $+$ $\frac{1}{2t - 1}$ $=$ 
$\ln(\frac{2t - 1}{2t})$ $+$ $\frac{1}{2t - 1}$ $=$ 
$\ln(\frac{2t - 1}{2t})$ $+$ $\frac{2t}{2t - 1}$ $-$ $\frac{2t - 1}{2t - 1}$ $=$
$\ln(\frac{2t - 1}{2t})$ $+$ $\frac{2t}{2t - 1}$ $-$ $1$ $=$
$\ln X$ $+$ $\frac{1}{X}$ $-$ $1$.
for $X$ $=$ $\frac{2t -1}{2t}$.
Notice that $0$ $&amp;lt;$ $X$ $&amp;lt;$ $1$.
Then, $\ln X$ $+$ $\frac{1}{X}$ $-$ $1$ $\ge$ $0$.
Proof is like follow.
If we derivated $y$ $=$ $\ln X$ $+$ $\frac{1}{X}$ $-$ $1$, $y’$ $=$ $\frac{1}{X}$ $-$ $\frac{1}{X^2}$ $=$ $\frac{X - 1}{X^2}$.
As a result, $y$ decreases in $0$ $&amp;lt;$ $X$ $&amp;lt;$ $1$.
However, it’s zero when $X$ $=$ $1$.
Therefore, $\ln X$ $+$ $\frac{1}{X}$ $-$ $1$ $\ge$ $0$.
As a result, this algorithm success to find a semicoloring in every iteration at least $\frac{1}{2}$ probability if $n$ $\ge$ $2$.&lt;/p&gt;

&lt;p&gt;Now, it doesn’t have too much meaning if you think about $n$ $=$ $1$.
Therefore, assumption isn’t too tight.&lt;/p&gt;

&lt;p&gt;Now, let’s see how many vertices are removed at each iteration.
If we start with $n’$ vertices, $\left\vert R \right\vert$ $\le$ $2 \frac{n’}{4}$ $=$ $\frac{n’}{2}$.
As a result, it will reduce to be half at least.
Therefore, there will be at most $O(1)$ vertices after part 2.
Notice that we will do part 2 at most $log_2 n$ time and it will be enough to be so.&lt;/p&gt;

&lt;p&gt;As a result color used in each part is like follow.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Part 1 uses at most $3([\frac{n}{\sigma}] + 1)$ $=$
$3([\frac{n}{n^{\log_6 3}}] + 1)$ $\le$
$3(\frac{n}{n^{\log_6 3}} + 1)$ $=$
$3(\frac{n^{\log_6 6}}{n^{\log_6 3}} + 1)$ $=$
$3(n^{\log_6 2} + 1)$ colors.&lt;/li&gt;
  &lt;li&gt;Part 2 uses at most $4\Delta^{\log_3 2}(\log_2 n)$ $\le$
$4\sigma^{\log_3 2}(\log_2 n)$ $=$
$4(n^{\log_6 3})^{\log_3 2}(\log_2 n)$ $=$
$4n^{\log_6 3 \cdot \log_3 2}(\log_2 n)$ $=$
$4n^{\log_6 2}(\log_2 n)$ colors.&lt;/li&gt;
  &lt;li&gt;Left part will use at most $O(1)$ colors.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;As a result, algorithm uses at most $3n^{\log_6 2}$ $+$ $3$ $+$ $4n^{\log_6 2}(\log_2 n)$ $+$ $O(1)$.
Therefore, claim holds.&lt;/p&gt;</content><author><name>Programelot</name></author><category term="algorithm" /><category term="approximation" /><summary type="html">We need some definitions and theorems to discuss about the coloring.</summary></entry><entry><title type="html">Markov’s inequality</title><link href="https://programelot.github.io/2021/05/14/Markovs-inequality/" rel="alternate" type="text/html" title="Markov's inequality" /><published>2021-05-14T00:00:00+09:00</published><updated>2021-05-14T00:00:00+09:00</updated><id>https://programelot.github.io/2021/05/14/Markovs%20inequality</id><content type="html" xml:base="https://programelot.github.io/2021/05/14/Markovs-inequality/">&lt;p&gt;If $X$ is a nonnegative random variable and $a \gt 0$ then,
$Pr[X \ge a]$ $\le$ $\frac{E(X)}{a}$.&lt;/p&gt;

&lt;p&gt;Proof is like follow.
First of all, $E(X | X \ge a)$ $\ge$ $a$ because condition means that varaible is greater or equal than $a$.
Simillary, $E(X | X \lt a)$ $\ge$ $0$ because $X$ is a nonnegative random variable.
Then, $E(X)$ $=$ $Pr[X \lt a] \cdot E(X | X \lt a)$ $+$ $Pr[X \ge a] \cdot E(X | X \ge a)$ $\ge$ $Pr[X \ge a] \cdot E(X | X \ge a)$ $\ge$ $Pr[X \ge a] \cdot a$.
Therefore, claim holds&lt;/p&gt;</content><author><name>Programelot</name></author><category term="algorithm" /><category term="approximation" /><summary type="html">If $X$ is a nonnegative random variable and $a \gt 0$ then, $Pr[X \ge a]$ $\le$ $\frac{E(X)}{a}$.</summary></entry></feed>